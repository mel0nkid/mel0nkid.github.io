[{"title":"[正则表达式与web前端] 一剂偏方，重构你的文章","tag":["前端","正则表达式"],"time":"2016-10-21 04:48:00","url":"/post/2016-10-21T04:48:00_regexp-skill","thumb":"/contents/2016-10-21T04:48:00_regexp-skill/thumb.jpg","content":"正则表达式是处理文本、数据的一剂良药，吃久了吃惯了才不觉得苦，PO主久病多年苦无良医，所以捣鼓了一些针对web前端方面的偏方。\n\n**【 功能主治 】**\n\n适用于以下人群及症状：\n* 内容妹纸：从网上拷下来的文章样式太乱，拿人手短。。。\n* 前端妹纸：某些内容的排版太繁琐，不想浪费青春。。。\n* 爬虫汉子：扒到的文章内容有点污，不想手洗。。。\n\n**【 禁忌人群 】**\n\n以下人群可能存在不良反应，请慎用此方：\n* 岁月静好，不怕麻烦和浪费青春的；\n* 有更牛X解决方案的；\n* 觉得我本人无聊的。。。\n\n下面以JS代码举例，主要介绍本人百无聊赖时总结出的一些短（lai）小（da）精（wo）悍（ya）的代码，用来重新定义和优化网页上的文章内容。\n\n### 1. 行内样式，洗洗更健康\n\n对于 css 样式来说，诸如 ```style=\"...\"``` 和 ```height=\"...\"``` 这样的行内样式，由于其优先级较高，容易一上场就干掉很多我们殚精竭虑码完的 css 样式。因此，如果你手里头有类似于下面这段 html 的代码，请务必先洗一洗：\n\n```html\n<div id=\"news-content\" class=\"news-content\"><!--content_start--><!--content_start--><p>　　2016年10月20日，在第七届中国高成长企业CEO峰会上，第十一届“中国最具投资价值企业50强”评选榜单（以下简称V50榜单）正式发布。该榜自2006年以来，至今已举办十一年之久，是投资界首个专注高成长企业的年度评选活动，被誉为“行业投资风向标”。</p><p>　　本届榜单在2015年风格的基础上进行了微调，根据企业发展的不同阶段与规模，将“中国最具投资价值企业50强”榜单评选，细分为“风云榜”（融资阶段A轮及其以后的未上市企业）和“新芽榜”（融资阶段A轮以前的未上市企业，创立时间两年以内）。</p><p>　　本届V50评选，自2016年3月初全面启动以来，广泛征集报名企业，经首轮筛选进入初评的企业达1000+，再通过严格的初评和复评，汇聚了近百位投资界“意见领袖”及<a href=\"http://newseed.pedaily.cn/company/2529\" target=\"_blank\">精英</a>们的专业意见，最终缔造了本届中国最具投资价值企业风云榜50强和新芽榜50强！</p><div><table border=\"1\"><tbody><tr><td colspan=\"3\"><p style=\"text-align:center;\"><b>2016</b><b>年第十一届中国最具投资价值企业50强榜单·新芽榜</b></p><p style=\"text-align:center;\">（此榜单排名不分先后，按企业全称首字母排序）</p></td></tr><tr><td><p><b>序号</b></p></td><td><p><b>企业简称</b></p></td><td><p><b>公司名称</b></p></td></tr><tr><td><p><b>1</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43432\" target=\"_blank\">POMCube</a></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43432\" target=\"_blank\">POMCube</a><a href=\"http://newseed.pedaily.cn/company/28649\" target=\"_blank\">Inc</a>.</p></td></tr><tr><td><p><b>2</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43348\" target=\"_blank\">京华未来</a></p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/43348\" target=\"_blank\">京华未来</a>机器人科技有限公司</p></td></tr><tr><td><p><b>3</b></p></td><td><p>玲珑</p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/38816\" target=\"_blank\">科玲文化科技</a>有限公司</p></td></tr><tr><td><p><b>4</b></p></td><td><p>联想<a href=\"http://zdb.pedaily.cn/people/智慧/\" target=\"_blank\">智慧</a>医疗</p></td><td><p>北京联想<a href=\"http://zdb.pedaily.cn/people/智慧/\" target=\"_blank\">智慧</a>医疗信息技术公司</p></td></tr><tr><td><p><b>5</b></p></td><td><p>灵犀微光</p></td><td><p>北京灵犀微光科技有限公司</p></td></tr><tr><td><p><b>6</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/42856\" target=\"_blank\">美信金融</a></p></td><td><p>北京美信众诚科技有限公司</p></td></tr><tr><td><p><b>7</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43249\" target=\"_blank\">魔视互动</a></p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/43249\" target=\"_blank\">魔视互动</a>科技有限公司</p></td></tr><tr><td><p><b>8</b></p></td><td><p>魔数科技</p></td><td><p>北京魔数科技有限公司</p></td></tr><tr><td><p><b>9</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/41882\" target=\"_blank\">潜力股</a></p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/41882\" target=\"_blank\">潜力股</a>科技有限公司</p></td></tr><tr><td><p><b>10</b></p></td><td><p>斑马社</p></td><td><p>北京青云<a href=\"http://newseed.pedaily.cn/company/28217\" target=\"_blank\">互帮</a>网络科技有限公司</p></td></tr><tr><td><p><b>11</b></p></td><td><p>深鉴科技</p></td><td><p>北京深鉴科技有限公司</p></td></tr><tr><td><p><b>12</b></p></td><td><p>住范儿</p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/42325\" target=\"_blank\">水木优品</a>科技有限公司</p></td></tr><tr><td><p><b>13</b></p></td><td><p>万娱引力</p></td><td><p>北京万娱引力文化传媒有限公司</p></td></tr><tr><td><p><b>14</b></p></td><td><p>细刻科技</p></td><td><p>北京细刻网络科技有限公司</p></td></tr><tr><td><p><b>15</b></p></td><td><p>医洋科技</p></td><td><p>北京医洋科技有限公司</p></td></tr><tr><td><p><b>16</b></p></td><td><p>艺妙神州</p></td><td><p>北京艺妙<a href=\"http://newseed.pedaily.cn/company/21983\" target=\"_blank\">神州医疗</a>科技有限公司</p></td></tr><tr><td><p><b>17</b></p></td><td><p>有序科技</p></td><td><p>北京有序科技有限公司</p></td></tr><tr><td><p><b>18</b></p></td><td><p>91金服</p></td><td><p>北京众智人人信息科技有限责任公司</p></td></tr><tr><td><p><b>19</b></p></td><td><p>水滴互助</p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/42462\" target=\"_blank\">纵情向前</a>科技有限公司</p></td></tr><tr><td><p><b>20</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43061\" target=\"_blank\">天仪研究院</a></p></td><td><p>长沙天仪空间科技研究院有限公司</p></td></tr><tr><td><p><b>21</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/42633\" target=\"_blank\">11Space</a></p></td><td><p>畅联管理咨询（北京）有限公司</p></td></tr><tr><td><p><b>22</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/39083\" target=\"_blank\">比呀比</a></p></td><td><p>广州<a href=\"http://newseed.pedaily.cn/company/39083\" target=\"_blank\">比呀比</a>信息科技有限公司</p></td></tr><tr><td><p><b>23</b></p></td><td><p><a href=\"http://zdb.pedaily.cn/people/金华/\" target=\"_blank\">金华</a>佗</p></td><td><p>广州杜仲哥互联网科技有限公司</p></td></tr><tr><td><p><b>24</b></p></td><td><p>康立明生物</p></td><td><p>广州市康立明生物科技有限责任公司</p></td></tr><tr><td><p><b>25</b></p></td><td><p>国民认证</p></td><td><p>国民认证科技（北京）有限公司</p></td></tr><tr><td><p><b>26</b><b></b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43634\" target=\"_blank\">维权骑士</a></p></td><td><p>杭州刀豆网络科技有限公司</p></td></tr><tr><td><p><b>27</b><b></b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/42379\" target=\"_blank\">文签网络</a></p></td><td><p>杭州<a href=\"http://newseed.pedaily.cn/company/42379\" target=\"_blank\">文签网络</a>技术有限公司</p></td></tr><tr><td><p><b>28</b><b></b></p></td><td><p>空中云汇</p></td><td><p>空中云汇（深圳）网络科技有限公司</p></td></tr><tr><td><p><b>29</b><b></b></p></td><td><p>爱诺医药</p></td><td><p>宁波爱诺医药科技有限公司</p></td></tr><tr><td><p><b>30</b><b></b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43199\" target=\"_blank\">埃德斯</a></p></td><td><p>上海<a href=\"http://newseed.pedaily.cn/company/43199\" target=\"_blank\">埃德斯</a>生物科技有限公司</p></td></tr><tr><td><p><b>31</b><b></b></p></td><td><p>幼师口袋</p></td><td><p>上海必加教育科技有限公司</p></td></tr><tr><td><p><b>32</b><b></b></p></td><td><p>果藤金融</p></td><td><p>上海果藤互联网金融信息服务有限公司</p></td></tr><tr><td><p><b>33</b><b></b></p></td><td><p>禾赛科技</p></td><td><p>上海禾赛<a href=\"http://newseed.pedaily.cn/company/23214\" target=\"_blank\">光电科技</a>有限公司</p></td></tr><tr><td><p><b>34</b><b></b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/42401\" target=\"_blank\">金枣金融</a></p></td><td><p>上海<a href=\"http://newseed.pedaily.cn/company/42401\" target=\"_blank\">金枣金融</a>信息服务有限公司</p></td></tr><tr><td><p><b>35</b><b></b></p></td><td><p>哮喘管家</p></td><td><p>上海朔茂网络科技有限公司</p></td></tr><tr><td><p><b>36</b><b></b></p></td><td><p>烯牛数据</p></td><td><p>上海烯牛信息技术有限公司</p></td></tr><tr><td><p><b>37</b><b></b></p></td><td><p>朋友印象</p></td><td><p>上海<a href=\"http://newseed.pedaily.cn/company/40089\" target=\"_blank\">阅人信息技术</a>有限公司</p></td></tr><tr><td><p><b>38</b><b></b></p></td><td><p>快金数据</p></td><td><p>深圳快金数据技术服务有限公司</p></td></tr><tr><td><p><b>39</b><b></b></p></td><td><p>莱斯购</p></td><td><p>深圳市莱斯购电子商务有限公司</p></td></tr><tr><td><p><b>40</b><b></b></p></td><td><p>寻材问料</p></td><td><p>深圳市寻材问料网络科技有限公司</p></td></tr><tr><td><p><b>41</b><b></b></p></td><td><p>万<a href=\"http://newseed.pedaily.cn/company/29464\" target=\"_blank\">瑞达</a>生物</p></td><td><p>深圳万<a href=\"http://newseed.pedaily.cn/company/29464\" target=\"_blank\">瑞达</a>生物科技有限公司</p></td></tr><tr><td><p><b>42</b><b></b></p></td><td><p>英美达</p></td><td><p>深圳英美达医疗技术有限公司</p></td></tr><tr><td><p><b>43</b><b></b></p></td><td><p>0glass</p></td><td><p>深圳增强现实技术有限公司</p></td></tr><tr><td><p><b>44</b><b></b></p></td><td><p>欧瑞吉医药</p></td><td><p>四川欧瑞吉生物医药股份有限公司</p></td></tr><tr><td><p><b>45</b><b></b></p></td><td><p>玩咖</p></td><td><p>玩咖欢聚文化传媒（北京）有限公司</p></td></tr><tr><td><p><b>46</b><b></b></p></td><td><p>一起火</p></td><td><p>衣旗（杭州）科技有限公司</p></td></tr><tr><td><p><b>47</b><b></b></p></td><td><p>标准普惠</p></td><td><p>颐月信息技术（北京）有限公司</p></td></tr><tr><td><p><b>48</b><b></b></p></td><td><p>水滴科技</p></td><td><p>银河水滴科技（北京）有限公司</p></td></tr><tr><td><p><b>49</b><b></b></p></td><td><p>娱猫</p></td><td><p>娱猫（北京）科技有限公司</p></td></tr><tr><td><p><b>50</b><b></b></p></td><td><p>北斗云点</p></td><td><p>珠海北斗云点信息技术有限公司</p></td></tr></tbody></table></div><p style=\"text-align:center;\">![新芽榜·2016年中国最具投资价值企业50强榜单](http://upload-images.jianshu.io/upload_images/590155-14755fa8a7bf8d94?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</p><p>　　<b>关于<a href=\"http://newseed.pedaily.cn/vc/38531\" target=\"_blank\">清科集团</a></b></p><p>　　<a href=\"http://newseed.pedaily.cn/vc/38531\" target=\"_blank\">清科集团</a>：成立于1999年，是中国领先的创业与投资综合服务平台及投资机构。旗下包括：清科研究中心、清科传媒、清科资本、清科财富、<a href=\"http://newseed.pedaily.cn/vc/110\" target=\"_blank\">清科创投</a>、清科母基金。主要业务涉及：研究咨询、数据产品、会议论坛、信息资讯、投资银行服务、直接投资、母基金管理及财富管理。</p><!--content_end--><!--content_pagestart--> <!--content_pageend--></div>\n```\n\n首先来清理一下这一坨里面的形如 ```<!--XXX-->``` 这样的注释语句和一些换行符（```\\n```, ```\\t```, ```\\r```）：\n\n```js\n// 这里用htmlStr表示刚才你看到的上面那一坨\nlet htmlStr = '...';\n// 匹配无用代码的正则\nlet pattForUselessCode = /(\\n|\\t|\\r|\\<\\!\\-\\-[^\\>]*\\-\\-\\>)/gi;\n// 将匹配项替换为空字符(即将无用代码从html字符串中剔除)\nhtmlStr = htmlStr.replace(pattForUselessCode, '');\n```\n\n接下来，清理 ```style=\"...\"``` 形式的行内样式：\n\n```js\nlet pattForStyleInline = /\\s(style)\\=\\\"[^\\\"]*\\\"/gi;    // 匹配行内样式的正则\nhtmlStr = htmlStr.replace(pattForStyleInline, '');\n```\n\n清理 ```height=\"...\"``` 形式的行内样式（主要目的在于清理 ```<img>``` 元素的行内宽度和高度，方便你在 css 中自己定义新的样式）：\n\n```js\nlet pattForSizeInline = /(\\s(height)\\=\\\"[^\\\"]*\\\"|\\s(width)\\=\\\"[^\\\"]*\\\")/gi;    // 匹配行内高、宽的正则\nhtmlStr = htmlStr.replace(pattForSizeInline, '');\n```\n\n注意：适当留下些有用的东西，比如：将 ```<p>``` 标签的 ```style=\"text-align:center\"``` 的样式通过 ```class``` 保留下来，我们可以知道哪些文字需要居中；将标签原有的 ```id```, ```class``` 等内容保留下来，也方便我们后期丰富 css 细节时，可以直接使用：\n\n```js\n// 匹配文字水平居中的p标签的正则\nlet pattForTextHorizontally = /\\<p[^(style|\\>)]+style\\=\\\"[^(\\\"|text)]*text\\-align\\:center\\;[^\\\"]*\\\"[^\\>]*\\>/gi;\n// 将<p style=\"...text-align:center...\">替换为<p class=\"text-center\">，而.text-center元素的样式你可以在css里面自己定义\nhtmlStr = htmlStr.replace(pattForTextHorizontally, '<p class=\"text-center\">');\n```\n\n做完上面这些工作，你就可以安安心心去写 css 了。。。这里我就不赘述了。。。\n\n灵活运用标签和选择器，你会发现，大多数网站的文章内容，虽然标签、结构不尽相同，但你仍能统一他们的表现风格。毕竟，经过清洗后留下来的东西，都是比较简单清晰的结构。\n\n最开始的那一坨，经过清理后，大概长这样：\n\n```html\n<div id=\"news-content\" class=\"news-content\"><p>　　2016年10月20日，在第七届中国高成长企业CEO峰会上，第十一届“中国最具投资价值企业50强”评选榜单（以下简称V50榜单）正式发布。该榜自2006年以来，至今已举办十一年之久，是投资界首个专注高成长企业的年度评选活动，被誉为“行业投资风向标”。</p><p>　　本届榜单在2015年风格的基础上进行了微调，根据企业发展的不同阶段与规模，将“中国最具投资价值企业50强”榜单评选，细分为“风云榜”（融资阶段A轮及其以后的未上市企业）和“新芽榜”（融资阶段A轮以前的未上市企业，创立时间两年以内）。</p><p>　　本届V50评选，自2016年3月初全面启动以来，广泛征集报名企业，经首轮筛选进入初评的企业达1000+，再通过严格的初评和复评，汇聚了近百位投资界“意见领袖”及精英们的专业意见，最终缔造了本届中国最具投资价值企业风云榜50强和新芽榜50强！</p><div><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr class=\"light-row\"><td colspan=\"3\"><p class=\"text-center\"><b>2016</b><b>年第十一届中国最具投资价值企业50强榜单·新芽榜</b></p><p class=\"text-center\">（此榜单排名不分先后，按企业全称首字母排序）</p></td></tr><tr><td class=\"dark-line\"><p><b>序号</b></p></td><td><p><b>企业简称</b></p></td><td class=\"dark-line\"><p><b>公司名称</b></p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>1</b></p></td><td><p>POMCube</p></td><td class=\"dark-line\"><p>POMCubeInc.</p></td></tr><tr><td class=\"dark-line\"><p><b>2</b></p></td><td><p>京华未来</p></td><td class=\"dark-line\"><p>北京京华未来机器人科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>3</b></p></td><td><p>玲珑</p></td><td class=\"dark-line\"><p>北京科玲文化科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>4</b></p></td><td><p>联想智慧医疗</p></td><td class=\"dark-line\"><p>北京联想智慧医疗信息技术公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>5</b></p></td><td><p>灵犀微光</p></td><td class=\"dark-line\"><p>北京灵犀微光科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>6</b></p></td><td><p>美信金融</p></td><td class=\"dark-line\"><p>北京美信众诚科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>7</b></p></td><td><p>魔视互动</p></td><td class=\"dark-line\"><p>北京魔视互动科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>8</b></p></td><td><p>魔数科技</p></td><td class=\"dark-line\"><p>北京魔数科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>9</b></p></td><td><p>潜力股</p></td><td class=\"dark-line\"><p>北京潜力股科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>10</b></p></td><td><p>斑马社</p></td><td class=\"dark-line\"><p>北京青云互帮网络科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>11</b></p></td><td><p>深鉴科技</p></td><td class=\"dark-line\"><p>北京深鉴科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>12</b></p></td><td><p>住范儿</p></td><td class=\"dark-line\"><p>北京水木优品科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>13</b></p></td><td><p>万娱引力</p></td><td class=\"dark-line\"><p>北京万娱引力文化传媒有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>14</b></p></td><td><p>细刻科技</p></td><td class=\"dark-line\"><p>北京细刻网络科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>15</b></p></td><td><p>医洋科技</p></td><td class=\"dark-line\"><p>北京医洋科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>16</b></p></td><td><p>艺妙神州</p></td><td class=\"dark-line\"><p>北京艺妙神州医疗科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>17</b></p></td><td><p>有序科技</p></td><td class=\"dark-line\"><p>北京有序科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>18</b></p></td><td><p>91金服</p></td><td class=\"dark-line\"><p>北京众智人人信息科技有限责任公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>19</b></p></td><td><p>水滴互助</p></td><td class=\"dark-line\"><p>北京纵情向前科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>20</b></p></td><td><p>天仪研究院</p></td><td class=\"dark-line\"><p>长沙天仪空间科技研究院有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>21</b></p></td><td><p>11Space</p></td><td class=\"dark-line\"><p>畅联管理咨询（北京）有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>22</b></p></td><td><p>比呀比</p></td><td class=\"dark-line\"><p>广州比呀比信息科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>23</b></p></td><td><p>金华佗</p></td><td class=\"dark-line\"><p>广州杜仲哥互联网科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>24</b></p></td><td><p>康立明生物</p></td><td class=\"dark-line\"><p>广州市康立明生物科技有限责任公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>25</b></p></td><td><p>国民认证</p></td><td class=\"dark-line\"><p>国民认证科技（北京）有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>26</b><b></b></p></td><td><p>维权骑士</p></td><td class=\"dark-line\"><p>杭州刀豆网络科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>27</b><b></b></p></td><td><p>文签网络</p></td><td class=\"dark-line\"><p>杭州文签网络技术有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>28</b><b></b></p></td><td><p>空中云汇</p></td><td class=\"dark-line\"><p>空中云汇（深圳）网络科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>29</b><b></b></p></td><td><p>爱诺医药</p></td><td class=\"dark-line\"><p>宁波爱诺医药科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>30</b><b></b></p></td><td><p>埃德斯</p></td><td class=\"dark-line\"><p>上海埃德斯生物科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>31</b><b></b></p></td><td><p>幼师口袋</p></td><td class=\"dark-line\"><p>上海必加教育科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>32</b><b></b></p></td><td><p>果藤金融</p></td><td class=\"dark-line\"><p>上海果藤互联网金融信息服务有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>33</b><b></b></p></td><td><p>禾赛科技</p></td><td class=\"dark-line\"><p>上海禾赛光电科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>34</b><b></b></p></td><td><p>金枣金融</p></td><td class=\"dark-line\"><p>上海金枣金融信息服务有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>35</b><b></b></p></td><td><p>哮喘管家</p></td><td class=\"dark-line\"><p>上海朔茂网络科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>36</b><b></b></p></td><td><p>烯牛数据</p></td><td class=\"dark-line\"><p>上海烯牛信息技术有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>37</b><b></b></p></td><td><p>朋友印象</p></td><td class=\"dark-line\"><p>上海阅人信息技术有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>38</b><b></b></p></td><td><p>快金数据</p></td><td class=\"dark-line\"><p>深圳快金数据技术服务有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>39</b><b></b></p></td><td><p>莱斯购</p></td><td class=\"dark-line\"><p>深圳市莱斯购电子商务有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>40</b><b></b></p></td><td><p>寻材问料</p></td><td class=\"dark-line\"><p>深圳市寻材问料网络科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>41</b><b></b></p></td><td><p>万瑞达生物</p></td><td class=\"dark-line\"><p>深圳万瑞达生物科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>42</b><b></b></p></td><td><p>英美达</p></td><td class=\"dark-line\"><p>深圳英美达医疗技术有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>43</b><b></b></p></td><td><p>0glass</p></td><td class=\"dark-line\"><p>深圳增强现实技术有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>44</b><b></b></p></td><td><p>欧瑞吉医药</p></td><td class=\"dark-line\"><p>四川欧瑞吉生物医药股份有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>45</b><b></b></p></td><td><p>玩咖</p></td><td class=\"dark-line\"><p>玩咖欢聚文化传媒（北京）有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>46</b><b></b></p></td><td><p>一起火</p></td><td class=\"dark-line\"><p>衣旗（杭州）科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>47</b><b></b></p></td><td><p>标准普惠</p></td><td class=\"dark-line\"><p>颐月信息技术（北京）有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>48</b><b></b></p></td><td><p>水滴科技</p></td><td class=\"dark-line\"><p>银河水滴科技（北京）有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>49</b><b></b></p></td><td><p>娱猫</p></td><td class=\"dark-line\"><p>娱猫（北京）科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>50</b><b></b></p></td><td><p>北斗云点</p></td><td class=\"dark-line\"><p>珠海北斗云点信息技术有限公司</p></td></tr></tbody></table></div><p class=\"text-center\">![新芽榜·2016年中国最具投资价值企业50强榜单](http://upload-images.jianshu.io/upload_images/590155-14755fa8a7bf8d94?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</p><p>　　<b>关于清科集团</b></p><p>　　清科集团：成立于1999年，是中国领先的创业与投资综合服务平台及投资机构。旗下包括：清科研究中心、清科传媒、清科资本、清科财富、清科创投、清科母基金。主要业务涉及：研究咨询、数据产品、会议论坛、信息资讯、投资银行服务、直接投资、母基金管理及财富管理。</p> </div>\n```\n\n### 2. 两句正则实现复杂的 table 明暗交替样式\n\n一般情况下，像 ```<table>``` 这样的东西，从几千年前活到现在，难免有些历史遗留的臭毛病，为保险起见，很多站点在拿到类似元素时，并没有花太多功夫去美化修饰，所以一臭百臭。\n\n下面是新芽（newseed）网站上的一篇文章的截图，可以看出，对于 table 标签的样式，适配的很不好，为曾经怀揣设计理想的我所不能容忍。\n\n![某网站文章页面对 table 标签的适配效果](http://upload-images.jianshu.io/upload_images/590155-cb63ef3fa792be0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n再下面是鄙人使用从该页面扒下来的同样的 html 结构实现的效果：\n\n![改良后的效果](http://upload-images.jianshu.io/upload_images/590155-2afd77f85a8a261c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n披了一件华丽的外套，与光着身子示人的感觉，毕竟有云泥之别。。。\n\n第二张图的样式，实现起来方法很多，主要的难点在于每行的背景色、每列的背景色都是明暗相间的。这个效果做起来，实现的方法有很多种：\n\n如果在客户端渲染页面，可以基于 DOM 操作：\n\n* 通过写一个或两个```for```循环 给 ```<tr>``` ```<td>``` 根据奇、偶数添加相应标记，如： 奇数列 ```<td class=\"light\">``` 偶数列 ```<td class=\"dark\">``` ，然后 css 再进行统一修饰。\n\n* 再考虑 ```:nth-child(even)``` ```:nth-child(odd)``` 这样的 css 伪类选择器写法，同样可以实现；或者用 jQuery 实现：\n\n```js\n$(\"#tab tr:nth-child(even)\").addClass(\"evenRow\");      // 添加偶数行样式\n$(\"#tab tr:nth-child(odd)\").addClass(\"oddRow\");        // 添加奇数行样式\n$(\"#tab td:nth-child(even)\").addClass(\"evenCol\");      // 添加偶数列样式\n$(\"#tab td:nth-child(odd)\").addClass(\"oddCol\");        // 添加奇数列样式\n```\n\n基于本文最初提到的那“坨” html 字符串，无从谈起操作 DOM，因而直接操作字符串：\n\n```js\n// 表格 - 奇数行浅灰\nhtmlStr = htmlStr.replace(/\\<tr\\>(.*?\\<\\/tr\\>\\<tr\\>.*?\\<\\/tr\\>)/gi, '<tr style=\"background:#f8f8f8;\">$1');\n```\n```\n// 表格 - 奇数列浅灰（使用半透明色值，与上面的行的背景色进行叠加）\nhtmlStr = htmlStr.replace(/\\<td\\>(.*?\\<\\/td\\>(\\<td\\>.*?\\<\\/td\\>)?)/gi, '<td style=\"background:rgba(0,0,0,.2);\">$1');\n```\n\n仅此两句，在不额外撰写 css 的情况下，实现了明暗交替的效果。\n"},{"title":"[web前端] JS: reduce 方法实现 webpack 多文件入口","tag":["前端工程化","nodejs"],"time":"2017-02-12 01:42:00","url":"/post/2017-02-12T01:42:00_webpack-skill","thumb":"/contents/2017-02-12T01:42:00_webpack-skill/thumb.jpg","content":"> 这篇日志，在开始接触 webpack 时候就该写了，现在发布也许对一些刚入此坑的童鞋能些许帮助。。。\n即使有点 low，重要的仍是分享\n\n## 1. reduce 方法介绍\n\n### 1.1 简单场景\n\nreduce 函数的设计意图就是方便进行叠加运算：\n\n```js\nvar arr = [0, 1, 2, 3];\n\n// reduce 实现累加\nvar total = arr.reduce(function (pre, cur){\n  return pre + cur;\n}, 0);\n\nconsole.log(total);    // 6\n```\n\n上述代码中，reduce 方法有两个参数，第一个参数是一个 callback，用于进行计算的函数；第二个参数则是累加计算的初始值: 0\nreduce 以 0 作为初始值，从数组第 0 项开始累加，上述代码的计算过程如下：\n\n```js\ntotal = 0;        // => 0\ntotal = 0 + 0;    // => 0\ntotal = 0 + 1;    // => 1\ntotal = 1 + 2;    // => 3\ntotal = 3 + 3;    // => 6\n```\n\n若不设置初始值 0，则 reduce 以数组第 0 项作为初始值，从第 1 项开始累加，其计算过程如下：\n\n```js\ntotal = 0;        // => 0\ntotal = 0 + 1;    // => 1\ntotal = 1 + 2;    // => 3\ntotal = 3 + 3;    // => 6\n```\n\n可以看出，reduce 函数根据初始值 0，不断进行叠加，完成最简单的数组累加。\n\n### 1.2 两种简单的运用场景\n\n第一个 demo，使用 reduce 函数进行二维数组的拼接：\n\n```js\nvar arr = [ [0], [1, 2], [3, 4, 5] ];\n\n// reduce 实现数组拼接\nvar result = arr.reduce(function (pre, cur){\n  return pre.concat(cur);\n}, []);\n\nconsole.log(result);    // [0, 1, 2, 3, 4, 5]\n```\n\n第二个 demo，使用 reduce 函数构造 JSON 数组：\n\n```js\n// 此例演示：将所有员工的姓名进行拆分\nvar staff = ['Bob Dell', 'Johon Jobs', 'Maria July'];\n\n// reduce 构造 JSON 数组\nvar result = staff.reduce(function (arr, full_name){\n  arr.push({\n    first_name: full_name.split(' ')[0],\n    last_name: full_name.split(' ')[1]\n  });\n\n  return arr;\n}, []);\n\nconsole.log(JSON.stringify(result));\n//  [{\"first_name\":\"Bob\",\"last_name\":\"Dell\"},{\"first_name\":\"Johon\",\"last_name\":\"Jobs\"},{\"first_name\":\"Maria\",\"last_name\":\"July\"}]\n```\n\n灵活使用 reduce 函数，能为我们节省不少中间变量和代码。\n\n## 2. 用于实现 webpack 多文件入口配置\n\nwebpack 配置项中```entry```参数用于配置入口文件路径，通常对于只打包一个目录下的文件，只需要遍历该目录，构造一个如下的对象传递给```entry```即可：\n\n```js\n// 注：index.js 为每个页面的入口文件，所有页面均在 ./fe/pages/ 目录下\nvar entry = {\n  index: './fe/pages/home/index.js',\n  list: './fe/pages/list/index.js'\n};\n```\n\n通常，我们使用 reduce 方法来遍历同一目录下的入口：\n\n```js\nvar fs = require('fs');\nvar path = require('path');\n...\n\n// 定义入口路径\nvar entryPath = './fe/pages';\n\n// 遍历路径下多文件入口\nvar entris = fs.readdirSync(entryPath).reduce(function (o, filename) {\n  !/\\./.test(filename) &&\n  (o[filename] = './' + path.join(entryPath, filename, 'index.js'));\n  return o;\n}, {});\n\n// entry = {\n//   index: './fe/pages/home/index.js',\n//   list: './fe/pages/list/index.js'\n// }\n```\n\n对于多页面应用的开发场景，也许会需要构造类似于下面这样的一个对象：\n\n```js\n// 多个入口，页面、公共组件并不一定在同一个目录下\nvar entry = {\n  index: './fe/pages/home/index.js',\n  list: './fe/pages/list/index.js',\n  header: './fe/components/header/index.js',\n  footer: './fe/components/footer/index.js'\n};\n```\n\n可以发现，我们要打包的页面、公共组件不一定在同一个目录下，这时候就需要对原先的方法进行扩展，见代码：\n\n```js\nvar fs = require('fs');\nvar path = require('path');\n...\n\n// 定义入口路径\nvar entryPath = ['./fe/pages', './fe/components'];\n\n// 遍历路径下多文件入口\nvar mkEntriesMap = function (entryPath){\n  if (typeof(entryPath) == 'string') {    // 若 entryPath 为字符串，则直接遍历此目录\n    var path_map = fs.readdirSync(entryPath).map(function (filename){\n      return filename + '::./' + path.join(entryPath, filename, 'index.js');\n    });\n  } else if (typeof(entryPath) == 'object') {    // 若 entryPath 为数组，则进行两级遍历\n    var path_map = entryPath.map(function (entry){\n      return fs.readdirSync(entry).map(function (filename){\n        return filename + '::./' + path.join(entry, filename, 'index.js');\n      });\n    }).reduce(function (preArr, curArr){\n      return preArr.concat(curArr);\n    }, []);\n  } else {\n    throw 'Type of config.entryPath is not valid.';\n    return;\n  }\n\n  return path_map.reduce(function (o, file_map){\n    var file_name = file_map.split('::')[0];\n    var file_path = file_map.split('::')[1];\n\n    if (!/\\./.test(file_name)) {\n      o[file_name] = file_path;\n    }\n\n    return o;\n  }, {});\n};\n\n// 构造对象\nvar entris = mkEntriesMap(entryPath);\n\n// entry = {\n//   index: './fe/pages/home/index.js',\n//   list: './fe/pages/list/index.js',\n//   header: './fe/components/header/index.js',\n//   footer: './fe/components/footer/index.js'\n// }\n```\n\n这样做的好处在于，只需配置一开始的```entryPath```就行了，同时支持单个或多个路径下的文件打包：\n\n```js\n// entryPath 可以为一个字符串\nvar entryPath = './fe/pages';\n\n// entryPath 也可以设为一个数组\nvar entryPath = ['./fe/pages', './fe/components'];\n```\n"},{"title":"[web前端发微] 潇洒地操作 window.history","tag":["前端"],"time":"2017-03-28 02:07:00","url":"/post/2017-03-28T02:07:00_browser-history","thumb":"/contents/2017-03-28T02:07:00_browser-history/thumb.jpg","content":"如果你想在 web 应用实现类似 pjax 的功能特性，往往需要做一些准备，比如对于不支持 history.pushState 方法的部分浏览器，怎样去做优雅降级，以满足页面整体的可用性等等。这篇文章主要来说说 pjax 相关的问题和思路。\n\n## 1. Why pjax?\n\n首先，因为我们必然会用到 ajax 来搞定数据，在 js 中执行的请求和 DOM 操作并不会被 history 记录（这么说虽然不严谨，帮助理解就好）；\n\n其次，单页面应用场景（或者某一个页面有多个交互状态的情况）下，浏览器的前进后退功能无法获取到某一次 ajax 操作或者交互的状态；\n\n第三（你以为我会说最后？so cute!），接前面所述，当页面在某种状态下被分享或者传播时，新的用户进入后，页面本应该维持在上个用户分享或传播时的状态（比如你经常在朋友圈分享的各种活动页面等等）...\n\n基于以上且不限于以上所述的种种需求，pjax 的策略便应运而生。\n\n![PJAX 机制（图片来源：百度搜索）](http://upload-images.jianshu.io/upload_images/590155-0f79eaf9595bd613.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. Pjax 的机制\n\n参考上面的示意图，用一种简单的方式来描述这个机制的过程：\n\n首先，在执行 ajax 操作时，我们使用 pushState 方法向 浏览器的 history 对象中写入一个特定的状态值（一组参数），保证每一次 ajax 请求都能有一个相应的 history 记录（history.state）；\n\n那么之后，当我们访问 history 的不同状态的时候（比如点击浏览器前进、后退按钮），通过当前状态值我们也能找到与之对应的 ajax 操作。\n\n这里 pushState 方法的一个好处，就是可以在不重载页面的情况下，改写浏览器地址栏 url（同时改变 window.location.href）。\n\n## 3. Pjax 的本质\n\nPjax 给我们提供了一个方案，而不仅仅是 pjax 的本身内容。我们至少可以从两个方面来拓展一下：\n\n> 如果没有 pushState，可以用其他方式来影响浏览器的历史记录吗？\n\n  * 如果你比较了解 React 或者 Angular 的 router 实现，那么这个问题很容易理解。比如 react-router 给予我们两种选择，一种是基于 history.pushState 的路由实现，一种是基于 location.hash 的实现，后者相对前者而言，适用性更强一些，毕竟 锚点 这个东西，在 web1.0 时代我们就很熟悉了。使用 location.hash 能够满足低版本浏览器的需要。\n\n> 如果把 ajax 操作换成其他操作呢？比如一般的 DOM 操作\n\n如此看来，借鉴于 pjax 的机制和原理，我们能干的事情很多。对于需要让浏览器记录的事件操作或者状态，我们按这个套路实现就好了。\n\n## 4. By the way, and how to do?\n\n基于上面的讨论，如果你已经有种想做点什么的冲动。那么，我想我们已经产生了共鸣。\n看到这里，不妨给文章点个赞或者丢几个硬币什么的，十分感激 (Xie-Xie-Ba-Ba)\n\n> 抛开单纯的 pjax 实现（比如 jquery-pjax 等等）\n如果我们可以自己做一个小工具（方法类库之类的）\n利用浏览器的 history 来驱动页面的操作或者行为\n解决更多的问题\n或者实现一个全新的功能\n是不是很 cool ？\n\n## 5. 欲望清单\n\n这个小标题看起来可能的有点中二（或者有点标题党吧）。。。\n\n从需求出发来考虑设计实现（需求驱动），是培养架构能力的好习惯。（~嘤~嘤~嘤）\n\n### 5.1 需求清单:\n\n* 我们想做一个更通用的 pushState 方法，用法如下（考虑逼格，展示 ES6 语法的伪代码）：\n\n```js\n// 以 import 形式引入依赖，easierHistory 是我们最终构造的方法集（一个对象或构造器）或者工具包\nimport easierHis from './easierHistory';\n\n// ...do something...\n\n// 向浏览器历史插入一条记录 （例如：我们做一个翻页的效果时，传入值为一个页码）\neasierHis.putState({page: 3});\n\n/* 注：为与原有 pushState 方法区别，故将新方法命名为 putState */\n```\n\n* 我们想通过一个方法（或者接口）访问到当前的历史状态（更通用的 history.state 方法）：\n\n```js\n// 获取当前历史状态 state\nlet { state } = easierHis.getState();\n\n/* 注：为与原有 state 方法区别，故将新方法命名为 getState */\n```\n\n* 构造一个通用的方法，当进行浏览器前进后退操作时，可以触发一些操作：\n\n```js\n// 获取当前历史状态 state\neasierHis.popState( (state) => { do something... } );\n\n/* 注：这里我们给 popState 方法传入一个回调，回调的内容就是我们想要触发的操作 */\n```\n\n### 5.2 一个完整的需求实例:\n\n综合考虑一个实际的应用场景，比如我们想要用自己构造的这种类 pjax 机制实现一个有记录、可前进回退的翻页效果。大致的实现如下：\n\n```js\nimport easierHis from './easierHistory';\n\n// 默认加载第 1 页数据\nif (!easierHis.getState()) {\n  loadPage(1);      // 用于翻页和加载数据的方法\n  easierHis.putState({page: 1});\n}\n\n// 浏览器前进/后退时，根据 state 数据加载对应页码的数据\neasierHis.popState((state) => {\n  let cur_page = !state ? 1 : parseInt(state.page);\n  loadPage(cur_page);\n});\n\n// 加载或跳转某页的方法\nfunction goto(page){\n  loadPage(page);\n  easierHis.putState({page: page});\n}\n```\n\n## 6. 具体实现\n\n从上一小节的需求出发，我们来看一看这个小工具（包）的具体实现。\n这里直接看代码，行文思路和具体方法的用法，可以参考代码注释：\n\n```js\n/* 基于 ES5 的 easierHistory 实现 */\n'use strict';\n\n// 全局对象\nvar easierHistory = {};\n\n/*\n** @method putState : 实现 类PJAX 机制的辅助函数，用于在 history 菊花上插一刀\n** @param {Object} state_content : 第 1 个参数(必填)，表示当前 state 的对象字面量\n** @param {Boolean} sync_prior : 第 2 个参数(选填)，传 true 则优先使用方案 $1，反之直接使用方案 $2，默认值为 true\n** @return {Object} _state : 返回 state\n**\n** $1 : 基于 history.pushState (绝大部分现代浏览器均支持)\n** $2 : 通过操作 url 的 hash 字符串内容的方式来进行兼容\n*/\neasierHistory.putState = function (state_content, sync_prior) {\n  var _state = arguments[0] || {};\n  var _prior = typeof arguments[1] == 'undefined' ? true : arguments[1];\n\n  // 拼接 search 和 hash 字符串\n  var _search = '?';\n  var _hash = '';\n  for (var key in _state) {\n    _search += key + '=' + _state[key] + '&';\n    _hash += '#' + key + '=' + _state[key];\n  }\n  _search = _search.replace(/\\&$|\\?$/, '');\n\n  // 根据浏览器支持情况，选择一种实现方式\n  if (!history.pushState || !_prior) {\n    location.hash = _hash;                       // $2 基于 location.hash 的实现\n  } else {\n    history.pushState(_state, '', _search);      // $1 基于 pushState 的实现\n  }\n\n  // 返回当前 state\n  return _state;\n}\n\n/*\n** @method getState_byHistory : 用于获取 history 状态\n** @return {Object} curState : 当前 history 状态\n*/\neasierHistory.getState_byHistory = function () {\n  if (history.state) {\n    return history.state;\n  }\n\n  if (location.search) {\n    return location.search.substring(1).split('&').reduce(function (curState, queryStr) {\n      if (queryStr.indexOf('=') !== -1) {\n        curState[queryStr.split('=')[0]] = queryStr.split('=')[1];\n      }\n\n      return curState;\n    }, {});\n  }\n\n  return null;\n};\n\n/*\n** @method getState_byHash : 将 location.hash 的内容解析为 json 对象\n** @return {Object} curState : 转换后的 json 对象\n*/\neasierHistory.getState_byHash = function () {\n  if (!location.hash) {\n    return null;\n  }\n\n  return location.hash.split('#').reduce(function (curState, hashStr) {\n    if (hashStr.indexOf('=') !== -1) {\n      curState[hashStr.split('=')[0]] = hashStr.split('=')[1];\n    }\n\n    return curState;\n  }, {});\n};\n\neasierHistory.getState = function () {\n  return easierHistory.getState_byHistory() || easierHistory.getState_byHash();\n};\n\n/*\n** @method popState : 给 window对象 绑定 popState 事件，若浏览器不支持则向下兼容 hashchange 事件\n** @param {Function} cbFunc : 事件回调\n*/\neasierHistory.popState = function (cbFunc) {\n  if (easierHistory.getState_byHistory()) {\n    window.onpopstate = function () {          // 基于 popstate 方法的实现（html5 特性）\n      cbFunc(easierHistory.getState());\n    };\n  } else {\n    window.onhashchange = function () {        // 基于 hashchange 方法的实现（兼容性更强）\n      cbFunc(easierHistory.getState());\n    };\n  }\n};\n\n\nmodule.exports = easierHistory;\n```\n\n当然，上面的代码可以直接在浏览器运行（直接使用 easierHistory对象），把 module.exports 语句去掉即可。\n"},{"title":"nodejs 终端打印进度条","tag":["nodejs"],"time":"2017-04-21 19:34:00","url":"/post/2017-04-21T19:34:00_nodejs-client-progress-bar","thumb":"/contents/2017-04-21T19:34:00_nodejs-client-progress-bar/thumb.jpg","content":"## 1. 场景导入\n\n当我们对大量文件进行批量处理的时候(例如：上传/下载、保存、编译等)，常常希望知道当前进展如何，或者失败(成功)的任务有多少；当我们的代码或程序已经发布，用户在执行安装的过程中，一个合适的（终端/命令行）进度条可以准确反映安装的步骤和进程，提升程序的可用性，一定程度缓解用户在等待中的烦恼……\n\n## 2. 基本原理\n\n首先，在终端打印出文本是件比较容易的事情。\n那么使用简单的文本和符号，就够自己拼凑出命令行的效果（下面例子）:\n\n```bash\n文件已上传: 43.60% █████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ 150/344\n```\n\n当然，进度条的效果可以根据需要自己设计啦，我这里只是给大家一个参考。\n\n这里，我将打印命令行的方法构造成一个工具模块 `progress-bar.js`，具体实现如下 :-)\n\n```js\n// 这里用到一个很实用的 npm 模块，用以在同一行打印文本\nvar slog = require('single-line-log').stdout;\n\n// 封装的 ProgressBar 工具\nfunction ProgressBar(description, bar_length){\n  // 两个基本参数(属性)\n  this.description = description || 'Progress';       // 命令行开头的文字信息\n  this.length = bar_length || 25;                     // 进度条的长度(单位：字符)，默认设为 25\n\n  // 刷新进度条图案、文字的方法\n  this.render = function (opts){\n    var percent = (opts.completed / opts.total).toFixed(4);    // 计算进度(子任务的 完成数 除以 总数)\n    var cell_num = Math.floor(percent * this.length);             // 计算需要多少个 █ 符号来拼凑图案\n\n    // 拼接黑色条\n    var cell = '';\n    for (var i=0;i<cell_num;i++) {\n      cell += '█';\n    }\n\n    // 拼接灰色条\n    var empty = '';\n    for (var i=0;i<this.length-cell_num;i++) {\n      empty += '░';\n    }\n\n    // 拼接最终文本\n    var cmdText = this.description + ': ' + (100*percent).toFixed(2) + '% ' + cell + empty + ' ' + opts.completed + '/' + opts.total;\n\n    // 在单行输出文本\n    slog(cmdText);\n  };\n}\n\n// 模块导出\nmodule.exports = ProgressBar;\n```\n\n## 3. Run 起来\n\n基于上面的实现，先说一下这个 `progress-bar.js` 的用法：\n\n```js\n// 引入工具模块\nvar ProgressBar = require('./progress_bar');\n\n// 初始化一个进度条长度为 50 的 ProgressBar 实例\nvar pb = new ProgressBar('下载进度', 50);\n\n// 这里只是一个 pb 的使用示例，不包含任何功能\nvar num = 0, total = 200;\nfunction downloading() {\n  if (num <= total) {\n    // 更新进度条\n    pb.render({ completed: num, total: total });\n\n    num++;\n    setTimeout(function (){\n      downloading();\n    }, 500)\n  }\n}\ndownloading();\n```\n\nrun 一下上面的代码，执行效果如下：\n\n![](http://upload-images.jianshu.io/upload_images/590155-0efe80d8c7068908.gif?imageMogr2/auto-orient/strip)\n"},{"title":"3D GIS 应用开发 —— 基于 Mapbox GL 的实践总结","tag":["GIS","webGL","3D可视化","前端"],"time":"2017-09-01 23:29:00","url":"/post/2017-09-01T23:29:00_mapbox-gl-js","thumb":"/contents/2017-09-01T23:29:00_mapbox-gl-js/thumb.jpg","content":"最近在折腾的 web 端的可视化项目，由于相关业务的需要，用到了 Mapbox 这一地图开发的神器。在此先奉上一个基于mapbox-gl实现的demo（来源：[uber的deck.gl项目](https://uber.github.io/deck.gl/#/)）：\n\n![demo](http://upload-images.jianshu.io/upload_images/590155-e16a70b0ec98c157?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n下面我们从这个项目一步步来介绍 Mapbox 的前端 GIS 引擎 [Mapbox GL JS](https://github.com/mapbox/mapbox-gl-js).\n\n## 1. 简单了解\n首先，Mapbox 在地图领域是一家很 Newbee 的公司。已为 Foursquare、Pinterest、Evernote、金融时报、天气频道、优步科技 等公司的网站提供了订制在线地图服务。\n\n自2010年起，该公司快速地拓展了订制地图的市场地位，以回应 Google地图 等地图供应商提供的有限选择。Mapbox 是一些开放源代码地图库及应用程序的创建者或最大的贡献者，其中包含了MBTiles 规范、TileMill 制图 IDE、Leaflet JavaScript 库，以及 CartoCSS 地图格式化语言与语法分析器等。\n\n该公司的数据同时从开放与专有的来源获取，开放的数据源如 开放街图（OSM, Open Street Map） 以及 NASA 等，而专有的数据源则包含了 DigitalGlobe。其技术奠基于 Node.js、CouchDB、Mapnik、GDAL 与 Leafletjs。\n\n[图片上传失败...(image-e27a1b-1515395418070)]\n\nMapbox 针对不同平台均开发了相应的 GIS 引擎以满足开发者或相关用户的需要，如：iOS SDK（用于iOS端开发）、Android SDK（用于Andriod端开发）、Navigation SDK（用于Navigation端开发）、Unity SDK（用于Unity端开发）、GL JS（用于web端开发）。不同平台的SDK，除使用方式不同外，功能特性上也多多少少存在不同。此外，Uber还针对react开发了 [react-map-gl](https://github.com/uber/react-map-gl)。总的来说，Mapbox的开源技术栈是非常全面的。\n\n## 2. 轻松上手\n\n[图片上传失败...(image-426b0b-1515395418070)]\n\nmapbox-gl 的 [文档](https://www.mapbox.com/mapbox-gl-js/api/) 由 API、Style Specification、Example、Plugins 四部分内容组成。\n\n顾名思义，API 是一般框架(类库)提供给用户的全部接口（方法）的说明书；Style Specification 是 Mapbox 地图的样式规范；Example 是一些常用功能或常见业务的代码示例，囊括了使用 Mapbox 所能实现的大部分功能效果；Plugins 则是官方推荐的可与 mapbox-gl 一同使用的一些增效插件和开源项目，如一些第三方的UI控件、显示类插件、框架集成工具、开发辅助工具、实用工具类库等等。\n\n对于初了解 Mapbox 的童鞋，建议先从官网的 Example 入手，能够较快掌握 mapbox-gl 的使用并投入开发实践。\n\n## 3. 快速实践\n\n下面以文章开头展示的项目为主，介绍其实战步骤。\n\n### 3.1 加载地图：\n由于使用在线地图服务和 `style` 时需要验证用户 `token`，所以在使用 `mapboxgl` 时需要先配置用户 `token`（在Mapbox官网注册用户即可获取）。\n\n```js\nimport mapboxgl from 'mapbox-gl';\nmapboxgl.accessToken = '<Your Token Here>';\n```\n\n接下来使用创建地图实例。主要配置项如下：\n\n```js\nconst myMap = new mapboxgl.Map({\n  container: '<Id of Container Element>',\n  style: '<Your Style Here>',\n  center: [112.508203125, 37.97980872872457],\n  zoom: 4,\n  pitch: 0,\n  bearing: 0,\n});\n```\n\n其中，`container` 是地图容器的元素 `id`，`style` 是地图样式的 `url`，或者你自己定义的 `style`（需遵循Mapbox样式规范），`center` 是地图加载后默认的中心点位置，用以定位地图加载时的位置。`zoom` `pitch` `bearing` 分别指缩放级别、地面法线偏移角、地轴偏移角等，用以确定当前视窗所显示的地图区域和空间关系。配置项的意义均可查看官网文档。\n\n### 3.2 绘制图形\n\n这里主要介绍视频中的3D建筑、飞线动画等是如何实现的。这里以相关代码片段来介绍实践的方法。\n\n在Mapbox中绘制图形时， `layer` 和 `source` 是最重要的一组概念，后者用于存储图形的数据内容，前者则是图形在3D场景中的表现（图层）。在Mapbox中，图层一旦被创建，与其同名（`id`相同）的数据源源（即`source`）也必然被创建。反之，也可以在创建source后再创建一个图层使用这个已创建的数据源，这时数据源与图层间并不要求同名。而我们通过改变数据来驱动图形变化，便是才去的第二种方式：\n\n```js\n// 创建id为buildings的数据源\nmyMap.addSource('buildings', {\n type: 'geojson',\n data: '<GeoJson Contents>',\n});\n\n// 使用buildings的数据来绘制id为building_layer的图形\nmyMap.addLayer({\n  id: 'building_layer',\n  type: 'fill-extrusion',\n  source: 'buildings',\n  ...<Other Options>,\n});\n```\n\n基于上面的方式，当数据改变时，我们只需要重设数据源的数据，即可驱动图层重绘：\n\n```js\nif (myMap.getLayer('building_layer')) {\n  myMap.getSource('buildings').setData(<New GeoJson Contents>);\n}\n```\n\n至于3D效果及动画的具体实现，这里给出两个官网上的示例，相信大家能一目了然：\n\n> i. [用3D形式呈现建筑](https://www.mapbox.com/mapbox-gl-js/example/3d-buildings/) \n> ii. [给路径中的一个点添加动画效果](https://www.mapbox.com/mapbox-gl-js/example/animate-point-along-route/)\n\n### 3.3 图形交互\n\nMapbox提供的交互方法是比较灵活的，活学活用API文档便能实现各种炫酷、实用的交互效果。比如：使用\n `myMap.on('zoom', callback)` 可以将图形与地图的缩放相绑定，当缩放系数小于某个值时，可以隐藏掉一些图形元素：\n\n```js\nmyMap.on('zoom', () => {\n  if (myMap.getZoom() <= 4) {\n    myMap.setLayoutProperty('building_layer', 'visibility', 'none');\n  } else {\n    myMap.setLayoutProperty('building_layer', 'visibility', 'visible');\n  }\n});\n```\n\n再比如，连续调用 `myMap.flyTo()` 的方法使视图在地图上按照一定的轨迹缓慢移动，可以给用户一种模拟飞行的体验。视频中的自动巡视的效果正是这样实现的。\n\n诸如 `click` `mouseover` `popup` 等效果，官网文档中的示例已经具体呈现，这里就不详细展开了。\n\n### 3.4 tiles-server的本地化\n由于 Mapbox 地图服务使用 MBTiles 存储数据，目前很多地图服务都接受了这套标准（如：OSM，Open Street Map）。所以可以通过搭建自己的 tiles-server 以替代直接使用 Mapbox 的在线地图服务。\n\n这样做的好处是显而易见的：一是可以通过负载均衡等手段提高数据接口的访问速度，有效提高数据的加载速度；一是保障应用能在零带宽的环境下仍能有效部署和使用。\n\n这里墙裂安利一个docker开源镜像：openmaptiles-server ，在其 [官网](https://openmaptiles.com/server/) 和 [dockerhub](https://hub.docker.com/r/klokantech/openmaptiles-server/) 上均可下载。个人认为其最大的亮点在于——即使不了解内部实现，也不影响其使用。\n\n![openmaptiles.com](http://upload-images.jianshu.io/upload_images/590155-007937c011da1d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n运行 tiles-server 服务的 docker 命令如下：\n\n```bash\n$ docker run --rm -it -v $(pwd):/data -p 8080:80\n```\n\n然后剩下来需要做的事情就是打开其导航页面 [http://localhost:8080/](http://localhost:8080/)（端口号取决于你的启动命令），然后跟着页面上的提示一步一步设置就好了（最后一步设置后会从OSM走动下载地图，所以一开始你不用担心数据从哪来），完全是傻瓜式的部署。\n\n## 4. 性能调优\n在 Mapbox GL 实践的过程中，发现了一些影响应用整体性能的因素，故而在此陈述一番，为之后填坑的童鞋提供一些经验：\n\n4.1 使用geo数据（如 GeoJson 格式数据）来定义图形的时候，若数据量过大，则会拖慢数据加载的速度，此时可考虑：\n\n* i. 在 http 请求前后对数据进行合理的压缩和解压，以尽可能节省 http 请求传输的数据量；\n* ii. 条件允许的情况下，可将一组数据分片加载，以空间换时间。\n\n4.2 在 Mapboox 中绘制的图层不宜过多，一是不方便管理（当然，github上有很多管理Mapbox图层的第三方工具），一是图层过多会明显降低GL的渲染和响应性能。所以在绘制图形前，可以先考虑一下图层的划分，以最少的图层实现尽可能多的效果。\n\n4.3 数据量相同的情况下，使用 `mapboxgl.Marker` 来添加标记，其性能不如使用 `type` 为 `symbol` 类型的图层来添加标记。原因在于前者生成的标记是一个个 DOM 元素，如果你可以想象在一个 web 页面中同时操作成百上千个 DOM 节点会是什么结果，那么你或许能明白我的建议。\n\n## 5. 一点总结\n最后，在此总结下个人对 Mapbox 的一些感观。\n\nMapbox 的产品定位是随时随地的 GIS（跨平台、应用），它为我们提供了一系列的简单操作的 API，使得 GIS 开发变得灵活而有趣。尤其对于开发 GIS 类型的数据可视化应用，Mapbox 是绝佳的选择。\n\n然而，如果你只是为了那些绚丽的 3D 效果的话，或许选择专门的框架更为合适。\n"},{"title":"amap-building-crawler 高德地图3D建筑信息爬虫项目","tag":["nodejs","爬虫","GIS","geojson"],"time":"2017-10-07 23:34:00","url":"/post/2017-10-07T23:34:00_amap-building-crawler","thumb":"/contents/2017-10-07T23:34:00_amap-building-crawler/thumb.jpg","content":"[amap-building-crawler](https://github.com/parksben/amap-building-crawler)\n\nA crawler project for fetching 3d building data from amap and tramsform its to GeoJSON.<br>\n高德地图3D建筑信息爬虫项目，用于爬取高德地图的 3D 建筑物数据，并将其转存为 GeoJSON 数据格式\n\n\n## Doc\n\n* Clone remote codes to local, then use the `yarn` command to install the project in local directory.\n\n* Execute `mkdir dist` in the project root directory (do not need to do this if the directory already exists).\n\n* Rewrite the latitude and longitude range in `index.js` file where you want to crawl the data (upper left corner & bottom right corner).\n\n```js\nconst lnglatRange = [\n  [118.01307678222655, 24.596143627409358],\n  [118.15830230712889, 24.452462684995407],\n];\n```\n\n* Execute `yarn start` in the project root directory, the retrieved data will be stored in the `dist` directory as a `.geojson` file.\n\n## 说明\n\n* clone 代码到本地，根目录使用 `yarn` 命令安装项目\n\n* 项目根目录下执行 `mkdir dist`（若目录已存在则不需要）\n\n* 修改 `index.js` 文件中需要爬取的坐标经纬度范围：\n\n```js\n// 需要爬取的经纬度范围（左上角、右下角）\nconst lnglatRange = [\n  [118.01307678222655, 24.596143627409358],\n  [118.15830230712889, 24.452462684995407],\n];\n```\n\n* 项目根目录下执行 `yarn start`，爬取的 `.geojson` 数据将存储到 `dist` 目录下\n"},{"title":"rgb-color-utils 又一个前端RGB颜色小工具","tag":["前端","npm包","工具"],"time":"2017-11-01 01:07:00","url":"/post/2017-11-01T01:07:00_rgb-color-utils","thumb":"/contents/2017-11-01T01:07:00_rgb-color-utils/thumb.jpg","content":"[项目git仓库](https://github.com/parksben/rgb-color-utils)\n\nA simple utils library for RGB colors which provides some convenient methods such as color interpolation, gradient generation, etc.\n\n## Installation\n```\nnpm install rgb-color-utils\n```\nor\n\n```\nyarn add rgb-color-utils\n```\n\n## Example Usage\n\n```js\nimport { parseColor, interpolate, gradientColor } from 'rgb-color-utils';\n\nconst colorList = parseColor('#cdab85'); // [205, 171, 133]\nconst newColor = interpolate('rgb(0, 23, 148)', '#febab5', 0.5); // '#7f69a5'\nconst colorMap = gradientColor('#bca380', '#00f', 4); // ['#bca380', '#8d7aa0', '#5e52c0', '#2f29df']\n```\n\n## API\n\n### parseColor(color)\n\n- `color` one RGB/HEX color string (`rgb(0, 23, 148)` or `#bf0081`)\n\n### interpolate(from, to, step)\n\n- `from` the starting position RGB/HEX color string (`rgb(0, 23, 148)` or `#bf0081`)\n- `to` the end position color string\n- `step` the normalized value (between 0 and 1) of the interpolation. A step of `0.5` would be the middle of `from` and `to`\n\n### gradientColor(from, to, length)\n\n- `from` the starting position RGB/HEX color string (`rgb(0, 23, 148)` or `#bf0081`)\n- `to` the end position color string\n- `length ` the length of the gradient colors array.\n\n## License\n\nMIT License\n"},{"title":"快速搭建你的 github pages 个人博客 —— 基于 Create-React-App 的单页面应用实践","tag":["前端","nodejs","react"],"time":"2018-01-28 10:26:17","url":"/post/2018-01-28T10:26:17_create-a-react-blog","thumb":"/contents/2018-01-28T10:26:17_create-a-react-blog/thumb.jpg","content":"相信各位github资深玩家们都有自己基于 `github pages` 搭建的个人站点。官方推荐的静态站点生成器是 `Jekyll`，关于 `Jekyll` 的使用感兴趣的各位请自行 google，这里就不赘述了。本文主要介绍下基于 `Create-React-App` 搭建个人博客的相关实践，可能更适合做前端开发的伙伴。\n\n![github pages](/contents/2018-01-28T10:26:17_create-a-react-blog/thumb.jpg)\n\n`github pages` 是 `github` 推出的静态站点服务，主要的用途在于使用你在 `github` 仓库中的代码构建你自己的静态站点，为用户提供 `github.io` 二级域名，您也可以通过添加DNS的 `CNAME` 记录来绑定自己的域名。\n\n`github pages` 最简单粗暴的方法就是直接往 github 上方静态页面了，创建一个名为 `[您的github账号名].github.io` 的github仓库，将您的index.html页面代码扔进master分支，就可以直接通过 `https://[您的github账号名].github.io` 访问到您的站点了。\n\n对于一个简单的个人博客站点来说，存在以下基本功能特性：\n\n* 文章的新增、编辑、一键发布\n* 文章的分类、归档yarn\n* 风格良好的博客样式\n* 评论、SEO等功能\n\n下面介绍基于React如何实现一个简单的静态博客。\n\n## 1. 创建一个 React 项目\n\n使用 Create-React-App（以下简称CRA） 的generator创建一个React前端项目骨架。对此项目进行一定改造以方便我们日常的开发和使用习惯：\n\n* 使用`react-app-rewired`来调整CRA中webpack的配置\n  * 对CRA的webpack配置感兴趣的童鞋可以看看[这篇文章](https://zhaozhiming.github.io/blog/2018/01/08/create-react-app-override-webpack-config/)\n* 使用`core-js`对浏览器版本进行向下兼容\n* 通过编写不同的React容器组件（container）来实现不同的页面，通过统一的json结构来配置应用的页面路由\n* 使用蚂蚁金服的`antd`设计语言（React组件）快速实现业务UI\n* 使用`axios`实现前后端的数据请求\n\n个人改造后的项目代码在[这里](https://github.com/parksben/react-spa-app)，您可以直接fork或者down下来使用。\n\n## 2. 使用 markdown 搞定你的文章\n### 2.1 用于新建文章的交互式命令行（基于 inquirer）\n\n一般的静态博客系统（如gatsby），会给用户提供一个用于创建新文章的交互式命令行，效果大致如下：\n\n![readline](/contents/2018-01-28T10:26:17_create-a-react-blog/readline.gif)\n\n类似功能可以使用nodejs中[readline模块](https://nodejs.org/dist/latest-v8.x/docs/api/readline.html)的原生方法来实现。这里推荐一个第三方工具：[inquirer](https://github.com/SBoudrias/Inquirer.js)，本质上是对readline模块进行了增强，提供了很多实用的方法用于交互式命令行开发，实现的用户界面（命令行）也比较友好。\n\n对于上面GIF示例的功能，其代码实现如下：\n\n```js\n// newPost.js\n\nconst inquirer = require('inquirer');\nconst moment = require('moment');\n\nconst questions = [\n  {\n    type: 'input',\n    name: 'post_name',\n    message: '请输入您的文章别名（用于创建文章目录，仅限英文，单词间用短横杠‘-’连接）：',\n    validate: value => {\n      if (/(\\.|\\*|\\?|\\\\|\\/)/gi.test(value)) {\n        return '文章别名不得包含特殊符号（.*?\\\\/），请重新输入↑↑';\n      }\n\n      if (/(([A-z]+-)+)?[A-z]+/gi.test(value)) {\n        return true;\n      }\n\n      return '文章别名不合法，请重新输入↑↑';\n    },\n    filter: value => value.replace(/\\s+/gi, '-'),\n  },\n  {\n    type: 'input',\n    name: 'create_at',\n    message: '请输入文章的发布时间（或者按回车键使用默认值）：',\n    default: () => {\n      return moment().format('YYYY-MM-DDThh:mm:ss');\n    },\n    validate: value => {\n      if (/\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d/gi.test(value)) {\n        return true;\n      }\n\n      return '时间格式不合法，请重新输入↑↑';\n    },\n  },\n];\n\ninquirer\n  .prompt(questions)\n  .then(answers => {\n    // 获取用户输入\n    const { post_name, create_at } = answers;\n\n    /* 此处做一些命令行反馈和过程性的工作 */\n    /* （如：提示用户输入是否合法、创建文章对应的目录和文件等等） */\n  })\n  .catch(err => {\n    /* 异常处理 */\n  });\n```\n\n如是，将此node脚本添加到项目`package.json`的`scripts`中（如：`new-post: \"node newPost.js\"`），即可通过`yarn new-post`命令运行。\n\n### 2.2 md 转 html（基于 react-markdown）\n\n为使用markdown文档来编辑、存储博客的文章内容，需要将md文档内容转换为react的JSX对象以渲染到网页中。在此推荐使用[react-markdown](https://github.com/rexxars/react-markdown)，功能很6，作者维护得也比较勤。\n\n使用方式如下：\n\n```js\nimport ReactMarkdown from 'react-markdown';\n\n<ReactMarkdown source={'# 这是文章标题\\n\\n'} />\n// <h1>这是文章标题</h1>\n```\n\n### 2.3 代码块的语法高亮\n\nreact-markdown提供了一个renderers属性，用户可以传入一系列renderer组件来自定义文章中一些内容的渲染方式（有兴趣的童鞋可以看下包作者对[默认renderer的实现](https://github.com/rexxars/react-markdown/blob/master/src/renderers.js)）。\n\n如：自定义md中图片的渲染方式（用法如下）。\n\n```js\n// 传入renderer的方式\n<ReactMarkdown\n  source={'[md文本内容]'}\n  renderers={{\n    image: ImageRenderer,\n  }}\n/>\n```\n\n```js\n// ImageRenderer的实现\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass ImageRenderer extends Component {\n  static propTypes = {\n    src: PropTypes.string.isRequired,\n  };\n\n  render() {\n    return (\n      <img\n        className=\"post-content-image\"\n        src={this.props.src}\n        alt={this.props.src}\n      />\n    );\n  }\n}\n\nexport default ImageRenderer;\n```\n\n与此类似，我们可以通过传入一个自定义的renderer来实现文章中代码块的语法高亮。名为`CodeBlock`的renderer实现如下：\n\n```js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { highlight, languages } from 'prismjs';\nimport ReactHtmlParser from 'react-html-parser';\nimport 'prismjs/themes/prism.css';\n\nexport class HtmlComponent extends Component {\n  static propTypes = {\n    html: PropTypes.string.isRequired,\n  };\n\n  render() {\n    return ReactHtmlParser(this.props.html);\n  }\n}\n\nexport class CodeBlock extends Component {\n  static propTypes = {\n    literal: PropTypes.string.isRequired,\n    language: PropTypes.string.isRequired,\n  };\n\n  render() {\n    const html = highlight(this.props.literal, languages[this.props.language]);\n    const cls = `language-${this.props.language}`;\n\n    return (\n      <pre className={cls}>\n        <code className={cls}>\n          <HtmlComponent html={html} />\n        </code>\n      </pre>\n    );\n  }\n}\n\nexport default CodeBlock;\n```\n\n此处用到了[prismjs](http://prismjs.com/)和[react-html-parser](https://github.com/wrakky/react-html-parser)两个npm包，前者用于将代码文本转化为html文本，后者用于将html文本转化为React的JSX对象以传入React组件（这样做比直接使用[dangerouslySetInnerHTML](https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml)属性更安全些）。\n\n## 3. 文章分类\n\n一个友好的站点肯定少不了导航菜单（或文章的分类菜单），本人的实现方式是直接使用文章的“标签”来进行分类统计，并生成站点的顶部导航，效果如下：\n\n![navigator](/contents/2018-01-28T10:26:17_create-a-react-blog/nav-top.png)\n\n为此，需要撰写一定的脚本实现文章的分类统计和打包，个人的实现方式是将统计结果和文章内容各自打包为json文件，通过前端组件请求数据并加载。\n\n导航栏组件的具体实现如下：\n\n```js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Link } from 'react-router-dom';\nimport { Dropdown, Menu, Icon } from 'antd';\nimport { randomId } from 'utils';\nimport './style.css';\n\nexport class Header extends Component {\n  static propTypes = {\n    data: PropTypes.array,\n    activeTag: PropTypes.string,\n  };\n\n  static defaultProps = {\n    data: [{ tag: '前端', count: 5 }],\n    activeTag: '',\n  };\n\n  constructor(props) {\n    super(props);\n    this.navTotal = 6;\n  }\n\n  renderMore() {\n    if (this.props.data.length <= this.navTotal) {\n      return false;\n    }\n\n    const subNavItems = this.props.data.slice(this.navTotal).map(t =>\n      <Menu.Item key={`sub_nav_${randomId()}`}>\n        <Link\n          to={t.linkTo || `/tag/${t.tag}`}\n          className={`ant-dropdown-link ${this.props.activeTag === t.tag\n            ? 'active'\n            : ''}`}\n          key={`nav_top_${randomId()}`}>\n          {t.tag}（{t.count}）\n        </Link>\n      </Menu.Item>\n    );\n\n    const SubNav = (\n      <Menu>\n        {subNavItems}\n      </Menu>\n    );\n\n    const DropDownBtn = (\n      <Dropdown overlay={SubNav} key={`nav_top_${randomId()}`}>\n        <div className=\"header-nav-item\">\n          更多分类 <Icon type=\"down\" />\n        </div>\n      </Dropdown>\n    );\n\n    return DropDownBtn;\n  }\n\n  renderTop5() {\n    const items = this.props.data.slice(0, this.navTotal - 1).map(t =>\n      <Link\n        className={`header-nav-item ${this.props.activeTag === t.tag\n          ? 'active'\n          : ''}`}\n        to={t.linkTo || `/tag/${t.tag}`}\n        key={`nav_top_${randomId()}`}>\n        {!t.linkTo ? `${t.tag}（${t.count}）` : t.tag}\n      </Link>\n    );\n\n    return (\n      <div className=\"header-nav\">\n        {items}\n        {this.renderMore()}\n      </div>\n    );\n  }\n\n  render = () => this.renderTop5();\n}\n\nexport default Header;\n```\n\n大家可以根据实际需要实现自己的文章打包方式（这里就不奉上我的脚本了😝）。\n\n## 4. 更多功能\n\n对于个人博客来说，到这里为止还有很多功能没有实现，这里偷个懒，奉上一些相关的链接吧：\n\n### 4.1 关于文章评论\n\n* [在github pagess中加入Disqus评论系统](http://www.forestofhorizon.com/notesofstudy/2015/12/01/adding-disqus-to-github-pages/)\n* [使用 GitHub Issues 搭建评论系统](https://imsun.net/posts/gitment-introduction/)\n\n### 4.2 关于文章结构树\n\n* [TreeMDown](https://github.com/hollodotme/TreeMDown)\n* [markdown-tree](https://github.com/hughsk/markdown-tree)\n\n我最近写了一个md文章的目录组件，各位大佬高兴的话可以赏个star:\n\n* [Markdown-Navbar](https://github.com/parksben/markdown-navbar)\n\n## 5. 发布你的个人静态站点\n### 5.1 部署到 github pages（基于 gh-pages）\n\nCRA针对github pages用途专门推荐了一个包：[gh-pages](https://github.com/tschaub/gh-pages)，使用方法如下：\n\n（1）修改项目的`package.json`文件，添加homepage属性：\n\n```\n\"homepage\": \"https://parksben.github.io\",\n```\n\n（2）项目安装`gh-pages`依赖后，在`package.json`中添加如下配置：\n\n```\n  \"scripts\": {\n+   \"predeploy\": \"npm run build\",\n+   \"deploy\": \"gh-pages -d build\",\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n```\n\n（3）将本地代码上传到github博客仓库的某个分支（只要不是master分支就行），然后执行：\n\n```\nyarn deploy\n```\n\ngh-pages会将CRA项目build到仓库的master分支，然后，你就可以访问你的站点了（有关 CRA 项目部署到 github pages 的详细描述可以看[这里](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#github-pages)）。\n\n### 5.2 如何兼容 React 的客户端路由（一种比较 hack 的方法）\n\n单页面应用一般需要设置服务端路由，将应用的所有页面路径都重定向到index.html，而github pages并没有这样的默认设置。\n\n因而，当你使用React的客户端路由（React的createBrowserHistory方法创建前端路由）时，除根路径以外的页面，github都会返回自己的404页面。\n\n为此，CRA项目提供了一种比较hack的方法来支持React的客户端路由（通过操作window.history来强行匹配url）。也算是一种奇技淫巧吧☺️。\n\n（1）在CRA项目的public目录下添加一个`404.html`，其内容如下：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>矮大紧的日常 | parksben's blog</title>\n    <script type=\"text/javascript\">\n      var segmentCount = 0;\n      var l = window.location;\n      l.replace(\n        l.protocol + '//' + l.hostname + (l.port ? ':' + l.port : '') +\n        l.pathname.split('/').slice(0, 1 + segmentCount).join('/') + '/?p=/' +\n        l.pathname.slice(1).split('/').slice(segmentCount).join('/').replace(/&/g, '~and~') +\n        (l.search ? '&q=' + l.search.slice(1).replace(/&/g, '~and~') : '') +\n        l.hash\n      );\n    </script>\n  </head>\n  <body>\n  </body>\n</html>\n```\n\n（2）在`index.html`的head中添加如下代码：\n\n```html\n<script type=\"text/javascript\">\n  (function(l) {\n    if (l.search) {\n      var q = {};\n      l.search.slice(1).split('&').forEach(function(v) {\n        var a = v.split('=');\n        q[a[0]] = a.slice(1).join('=').replace(/~and~/g, '&');\n      });\n      if (q.p !== undefined) {\n        window.history.replaceState(null, null,\n          l.pathname.slice(0, -1) + (q.p || '') +\n          (q.q ? ('?' + q.q) : '') +\n          l.hash\n        );\n      }\n    }\n  }(window.location))\n</script>\n```\n\n大功告成，你的github站点支持React的客户端路由了。\n\n除此之外，也可以改为使用`createHashHistory`方法来创建客户端路由，这样前端路由就与服务端路由没多大关系了，不过url里面一串hash毕竟不够优雅。\n\n有兴趣了解奇技淫巧的童鞋，可以点[这里](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#notes-on-client-side-routing)。\n\n### 5.3 部署到自己的服务\n\n与CRA项目的生产环境部署方式一样：\n\n* 线上执行 yarn build 命令，站点的所有静态资源将打包到 build 目录下\n* 将你的站点入口配置到 build 目录下\n\n## 6. 项目参考（源码奉上）\n\n![parksben.github.io](/contents/2018-01-28T10:26:17_create-a-react-blog/my-blog.png)\n\n这是[我的github博客](https://parksben.github.io/)（基于上述过程实现的静态站点），感兴趣的伙伴可以[点击这里](https://github.com/parksben/parksben.github.io)查看项目源码，觉得有用也可以fork或star一下下。\n"},{"title":"Markdown-Navbar","tag":["markdown","navbar","react","前端"],"time":"2018-02-25 05:28:08","url":"/post/2018-02-25T05:28:08_markdown-navbar","thumb":"/contents/2018-02-25T05:28:08_markdown-navbar/thumb.jpg","content":"Best markdown navigation bar for React.\n\n[git repo](https://github.com/parksben/markdown-navbar)\n\n## Install\n\n```\nyarn add markdown-navbar\n```\nor\n\n```\nnpm install markdown-navbar\n```\n\n## Usage\n\n```js\nimport MarkNav from 'markdown-navbar';\nimport 'markdown-navbar/dist/navbar.css';\n\nconst content = '## Heading One...\\n\\n## Heading Two...\\n';\n\n<MarkNav\n  className=\"article-menu\"\n  source={content}\n  headingTopOffset={80}\n/>\n```\n\n## Screenshots\n\n![Screenshots](/contents/2018-02-25T05:28:08_markdown-navbar/markdown-navbar.gif)\n\n## Options\n\n|property|type|default value|use|\n|:-:|:-:|:-:|:-:|\n|className|string|\"\"|The className that defines the outermost container of navbar|\n|source|string|\"\"|Markdown text content|\n|headingTopOffset|number|0|Anchor relative to the top of the window displacement (for the anchor jump)|\n|ordered|boolean|true|Whether the title contains a numerical prefix, such as: `1. 2. 2.2`|\n\n## License\n\n`Markdown-Navbar` is released under the MIT license.\n"},{"title":"然并卵：BF 科普 & BF 解释器的 JS 实现","tag":["brainFuck","其他"],"time":"2018-08-12 21:54:38","url":"/post/2018-08-12T21:54:38_brainfuck-interpreter-of-js","thumb":"/contents/2018-08-12T21:54:38_brainfuck-interpreter-of-js/thumb.jpg","content":"![图片来源：google 搜索](/contents/2018-08-12T21:54:38_brainfuck-interpreter-of-js/thumb.jpg)\n\n最近在 [Codewars](https://www.codewars.com/ )上做练习，某道题的内容是实现一个 brainFuck（简称BF语言） 解释器（c/python/js等等均可）。动手实践的过程还是很有趣的，中间也遇到了各种各样的问题，最终通过测试，代码也比较接近目前的 JS 高分 solution。这篇文章准备聊聊相关的一些知识和实现的细节。\n\n## “脑洞大开”的语言 —— BF 简介\n\nBrainfuck（后文以简写BF指代），单是名字就很容易让人脑洞大开，有种不可描述的“哲学”韵味。所以如果你忍不住 google 一下相关图片的话，你会可能搜到类似下面的图片：\n\n![图片来源：google 搜索](/contents/2018-08-12T21:54:38_brainfuck-interpreter-of-js/bf_brief.jpeg)\n\n**画面是不是已经很生动了？**\n\nBF 字面上的含义已经暗示了这是一种不太直观和容易阅读的语言，当然，在当下也不会是一种通用语言。她属于 Esolang（全称 Esoteric programming language，直译：深奥的编程语言） 的范畴。\n\nBF诞生于上世纪30年代，曾运用于早期的 PC（Amiga），想详细了解的童鞋可以浏览 [维基百科](https://zh.wikipedia.org/wiki/Brainfuck)。\n\n**BF 在当下有什么应用场景呢？**\n\n我想，对一个吃瓜群众来说，了解了它，对写作 **逼格** 和 **脑力** 的提升是很有用的。BF 具有**极简主义**（搞设计的童鞋的不妨了解下下）和**功能齐全**（图灵完全）的特点，旨在为用户带来困惑和挑战，丰富劳动人民的业余生活。\n\n## 8 种运算符及其操作\n\nBF 作为一种极简的计算机语言，仅有8种运算符，分别为: `<` `>` `+` `-` `,` `.` `[` `]`，其功能对照如下表所示：\n\n| 指令 | 含义 |\n|:---:|:---:|\n| `<` | 指针减一（指针左移） |\n| `>` | 指针加一（指针右移） |\n| `+` | 指针指向的字节的值加一（当前单元的数值+1） |\n| `-` | 指针指向的字节的值减一（当前单元的数值-1） |\n| `,` | 输入内容到指针指向的单元（输入一个字符，将其ASCII码保存到当前指针所指单元） |\n| `.` | 将指针指向的存储单元的内容作为字符输出（将ASCII码输出为字符） |\n| `[` | 如果指针指向的存储单元为零，向后跳转到对应的 `]` 指令处 |\n| `]` | 如果指针指向的存储单元不为零，向前跳转到对应的 `[` 指令处 |\n\nBF基于一个简单的机器模型，除了八个指令，这个机器还包括：一个以字节为单位、被初始化为零的数组、一个指向该数组的指针(初始时指向数组的第一个字节)、以及用于输入输出的两个字节流。\n\n对 BF 比较有意思的比拟可以是这样的：\n\n1. 如果把机器内存看成是一个无限长的“小火车”（类似于`Array`或`List`的数据结构）,每个车厢（存储单元）里面的货物默认都是数字 `0`，列车上仅有一个列车员（数据指针）；\n2. `<>` 相当于列车员在车厢间进行移动，只有当列车员在某节车厢时，才能对车厢的货物进行操作；\n3. `+-` 相当于列车员对当前所在车厢的货物进行增减；\n4. `,` 相当于列车在装货，列车员将当前所在车厢的货物替换为货运站输入的单批次货物（一个字符的ASCII码）；\n5. `.` 会将当前车厢里的货物名称（单个字符）出来；\n6. `[]` 相当于列车员在满足条件的两节车厢间来回移动；\n\n这里要注意的是，数组的每个单元都是一个字节大小；`-` 命令允许溢出，它可以用 255 个 `+` 命令来代替。例如，当某个存储单元的值为 255 时，其执行指令 `+` 的结果为 0。类似的， 0 执行指令 `-` 的结果为 255.\n\n## 与通用语言的类比\n\n据此，BF的运算符与通用语言的类比如下（以C语言为例）：\n\n| BrainFuck | C |\n|:-:|:-:|\n| `<` | `--ptr;` |\n| `>` | `++ptr;` |\n| `+` | `++*ptr;` |\n| `-` | `--*ptr;` |\n| `,` | `*ptr = getchar();` |\n| `.` | `putchar(*ptr);` |\n| `[` | `while (*ptr) {` |\n| `]` | `}` |\n\n## BF 解释器的 JS 函数实现\n\n### 代码奉上：\n\n```js\nfunction brainLuck(code, input) {             // @1\n  const inputChars = input.split('');         // @2\n\n  const codes = code.split('');               // @3\n  let codeIdx = 0;\n\n  const arr = [];                             // @4\n  let arrIdx = 0;\n  let outputStr = '';                         // @5\n\n  while (codeIdx < code.length) {             // @6\n    const ops = codes[codeIdx];\n\n    const handleLeftBracket = () => {         // @7\n      if (~~arr[arrIdx] === 0) {\n        let cnt = 1;\n\n        while (cnt) {\n          codeIdx++;\n          if (codes[codeIdx] === '[') {\n            cnt += 1;\n          }\n          if (codes[codeIdx] === ']') {\n            cnt -= 1;\n          }\n        }\n      }\n    };\n\n    const handleRightBracket = () => {        // @8\n      if (~~arr[arrIdx] !== 0) {\n        let cnt = 1;\n\n        while (cnt) {\n          codeIdx--;\n          if (codes[codeIdx] === ']') {\n            cnt += 1;\n          }\n          if (codes[codeIdx] === '[') {\n            cnt -= 1;\n          }\n        }\n      }\n    };\n\n    switch (ops) {                            // @9\n      case '>':\n        arrIdx += 1;\n        break;\n      case '<':\n        arrIdx -= 1;\n        break;\n      case '+':\n        arr[arrIdx] = (~~arr[arrIdx] + 1) % 256;\n        break;\n      case '-':\n        arr[arrIdx] = (~~arr[arrIdx] || 256) - 1;\n        break;\n      case ',':\n        const iptChar = inputChars.shift();\n        arr[arrIdx] = iptChar ? iptChar.charCodeAt(0) : arr[arrIdx];\n        break;\n      case '.':\n        outputStr += String.fromCharCode(arr[arrIdx]);\n        break;\n      case '[':\n        handleLeftBracket();\n        break;\n      case ']':\n        handleRightBracket();\n        break;\n    }\n\n    codeIdx++;                               // @10\n  }\n\n  return outputStr;                          // @11\n}\n\n```\n\n### 实现思路阐述（与代码中注释的序号对应）：\n\n(1) 我们实现了一个函数 brainLuck 用以模拟 BF 语言的解释执行，函数 brainLuck 的用例如下：\n\n```js\nconst code = ',+[-.,+]';\nconst input = 'Parksben' + String.fromCharCode(255);\n\nconst output = brainLuck(code, input);\nconsole.log(output); // -> 'Parksben'\n```\n\n(2) 将输入的字符串切割为单个字符，暂存进数组 inputChars；\n\n(3) 将 BF 程序切割为单个操作符，方便遍历每个指令，用 codeIdx 作为下标进行遍历；\n\n(4) 声明一个数组 arr 用以模拟机器内存，过程产生的数值存储到此数组中；\n\n(5) 用字符串 outputStr 存储程序的输出；\n\n(6) 遍历 BF 运算符，对不同指令进行相应的操作；\n\n(7) 方法 handleLeftBracket，用以匹配到与当前 `[` 对应的 `]`（通过操作下标 codeIdx）；\n\n(8) 方法 handleRightBracket，用以匹配到与当前 `]` 对应的 `[`（通过操作下标 codeIdx）；\n\n(9) 用以处理不同指令的 switch 语句；\n\n(10) codeIdx 加一，以向前遍历 codes；\n\n(11) 程序输出；\n\n## 延伸阅读\n\n[Brainfuck: a Programming Language or a Joke?](https://vironit.com/brainfuck-a-programming-language-or-a-joke/)\n\n[丹尼尔·克里斯托法尼的一些 BF 实例](http://www.hevanet.com/cristofd/brainfuck/)\n\n[深奥的编程语言 - 维基百科](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%A5%A5%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80)\n"},{"title":"[小清新] 一段 node 脚本生成风格优雅的 Directory Tree","tag":["前端","nodejs"],"time":"2018-10-03 06:34:00","url":"/post/2018-10-03T06:34:00_make-directory-tree-with-nodejs","thumb":"/contents/2018-10-03T06:34:00_make-directory-tree-with-nodejs/thumb.jpg","content":"![via: Google image search](/contents/2018-10-03T06:34:00_make-directory-tree-with-nodejs/thumb.jpg)\n\n## 一些烦恼\n\n如果你常常在博客中插入一些文件目录结构，不免会有碰到诸如此类的问题：\n\n* 使用图片输出的话，感官上不够和谐，尤其在移动端环境下，图片内容可能会被多次转码、缩放以至于影响阅读体验。\n* 使用文本输出的话，在不同设备、编辑器下内容排版容易混乱。\n* 某一天，你想修改一下内容或者结构时，一个字符一个字符的编辑简直让人抓狂。\n* 使用文本输出的另一个毛病就是，不同设备、平台的字号、字体、字符样式都不一样。也许你写的时候觉得足够有美感，在受众的设备里却如同一坨翔。\n\n## 解决方案\n\n由于但不限于上述种种原因，自己写了一个小脚本，可以顺利地实现目录树的生成。结果被输出为html片段，通过附加CSS样式，效果远好于前几种的方式。\n\n脚本输出的 html 长这样：\n\n~~~html\n<style>\n  .parksben-is-just-one-single-doge {\n    width: 90%;\n    max-width: 640px;\n    box-sizing: border-box;\n    margin: 1em auto;\n    padding: 2em;\n    background: #333;\n    border-radius: 5px;\n    overflow: hidden;\n    font: 14px/18px Helvetica, Arial, \"Microsoft Yahei\", Verdana, sans-serif;\n    --content-color: #fff;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree {\n    color: var(--content-color);\n  }\n\n  .parksben-is-just-one-single-doge ul.tree,\n  .parksben-is-just-one-single-doge ul.tree ul {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree ul {\n    margin-left: 1em;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree li {\n    margin: 0;\n    padding: 0 1em;\n    line-height: 2em;\n    font-weight: bold;\n    position: relative;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree li::before {\n    content: '';\n    display: block;\n    width: 1px;\n    height: 100%;\n    background: var(--content-color);\n    position: absolute;\n    left: 0;\n    top: 0;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree li::after {\n    content: '';\n    display: block;\n    width: 0.8em;\n    height: 1px;\n    background: var(--content-color);\n    position: absolute;\n    left: 0;\n    top: 0.9em;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree li:last-child::before {\n    height: 1em;\n    bottom: 1em;\n  }\n</style>\n<div class=\"parksben-is-just-one-single-doge\">\n  <ul class=\"tree\"><li>app.css</li><li>app.js</li><li>components<ul><li>Bar3d<ul><li>index.js</li><li>shaders<ul><li>index.js</li></ul></li><li>style.css</li><li>utils<ul><li>mesh.js</li><li>webgl.js</li></ul></li></ul></li><li>Button<ul><li>index.js</li><li>style.css</li></ul></li><li>DragImg<ul><li>index.js</li><li>style.css</li></ul></li><li>PlayStarBySvg<ul><li>index.js</li><li>style.css</li></ul></li><li>PlayStarInCanvas<ul><li>index.js</li><li>style.css</li></ul></li></ul></li><li>utils<ul><li>index.js</li></ul></li></ul>\n</div>\n~~~\n\n显示的效果长这样（清新脱俗的黑白配、肥而不腻的字形，要多优雅有多风骚）：\n\n![Directory tree](/contents/2018-10-03T06:34:00_make-directory-tree-with-nodejs/directory.jpg)\n\n## 源码奉上\n\n很简单的东西，这里直接直接献上代码吧。如果确实能给大家带来一丢丢的效率，我就很欣慰了，或者大家有什么更优雅而高效的东东，不妨留言给我安利安利。\n\n~~~js\n/*\n** File:  `makeTree.js`\n** Usage: `node makeTree.js ./`\n*/\n\nconst fs = require('fs');\nconst path = require('path');\n\nfunction makeHtml(dir) {\n  const items = fs.readdirSync(dir).map(file => {\n    let str = file;\n\n    const filePath = path.join(dir, file);\n    if (fs.lstatSync(filePath).isDirectory()) {\n      str += makeHtml(filePath);\n    }\n\n    return `<li>${str}</li>`;\n  });\n\n  return `<ul>${items.join('')}</ul>`;\n}\n\nconst dirToShow = process.argv[2] || './';\nconst treeStr = makeHtml(path.join(__dirname, dirToShow.trim()));\n\nconst containerName = 'parksben-is-just-one-single-doge';\nconst htmlStr = `<style>\n  .${containerName} {\n    width: 90%;\n    max-width: 640px;\n    box-sizing: border-box;\n    margin: 1em auto;\n    padding: 2em;\n    background: #333;\n    border-radius: 5px;\n    overflow: hidden;\n    font: 14px/18px Helvetica, Arial, \"Microsoft Yahei\", Verdana, sans-serif;\n    --content-color: #fff;\n  }\n\n  .${containerName} ul.tree {\n    color: var(--content-color);\n  }\n\n  .${containerName} ul.tree,\n  .${containerName} ul.tree ul {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  .${containerName} ul.tree ul {\n    margin-left: 1em;\n  }\n\n  .${containerName} ul.tree li {\n    margin: 0;\n    padding: 0 1em;\n    line-height: 2em;\n    font-weight: bold;\n    position: relative;\n  }\n\n  .${containerName} ul.tree li::before {\n    content: '';\n    display: block;\n    width: 1px;\n    height: 100%;\n    background: var(--content-color);\n    position: absolute;\n    left: 0;\n    top: 0;\n  }\n\n  .${containerName} ul.tree li::after {\n    content: '';\n    display: block;\n    width: 0.8em;\n    height: 1px;\n    background: var(--content-color);\n    position: absolute;\n    left: 0;\n    top: 0.9em;\n  }\n\n  .${containerName} ul.tree li:last-child::before {\n    height: 1em;\n    bottom: 1em;\n  }\n</style>\n<div class=\"${containerName}\">\n  <ul class=\"tree\">${treeStr.slice(4)}\n</div>\n`;\n\nfs.writeFileSync(path.join(__dirname, 'tree.html'), htmlStr, 'utf8');\nconsole.log('==> Done: the directory tree is saved to ./tree.html');\n~~~\n\n## 局限性\n\n这样做解决了一部分问题，至少往自己的博客文章里放问题不大。\n\n但还有很大的局限性，比如对于掘金、简书、知乎这样的第三方页面，直接插 CSS 很难完全覆盖已有的样式，工作也很繁琐。\n\n个人想到的另一个办法是把内容输出成 svg，这样，在保证样式和内容正确性的同时，读者也可以直接 copy 上面的文字。这个我打算下一步弄下，可行的话再把代码 push 出来。\n\n## 后续\n\n最后再废话一两句，最近有很多东西感觉可以分享出来，比如下一篇文章我准备写写 webGL 的一些内容，或者地图开发方面的内容。先在这里挖个坑，好逼迫一下自己。\n\n好长一段时间没写文章了，加班、通宵什么的都不是借口，大好时光可不能就此荒废。\n"},{"title":"批量轨迹存储压缩算法","tag":["轨迹","GIS"],"time":"2020-07-05 11:40:40","url":"/post/2020-07-05T11:40:40_trace-query","thumb":"/contents/2020-07-05T11:40:40_trace-query/thumb.jpg","content":"### 业务背景\n &nbsp;&nbsp;&nbsp;如果我们在某些场景中，需要存储和查询批量轨迹点(查询历史轨迹)。比如，一个小件员过去几天的经纬度坐标数据。如果app采集小件员轨迹的频率是1个/1秒。那么一天如果工作8小时，一天一个小件员的轨迹量是8*60*60 = 28800个轨迹点。我们通常的做法是将小件员的实时位置信息采集存储到Hbase。那么如果有客户一次查询3天的轨迹数据，那么Hbase内部查询+HBASE到本服务的网络IO+本服务(不做任何操作直接范围)到客户端的网络IO会是一个比较大的RT。目前测试，使用阿里内部的HBASE一次查询3W+的轨迹点耗时>1s。这对某些业务是不能忍受的。所以我们必须采取其他办法对这些轨迹点进行压缩。\n\n### 目前采取的轨迹存储\n存储DB：HBASE  \nRK: userId_timestamp  \nval: f:lon, f:lat\n这种方式的存储，如果需要查询某个用户一段时间的轨迹序列，只需:  \n```java\n    startRk = userId_startQueryTimestamp;\n    endRk = userId_endQueryTimestamp;\n    hbase.scan(startRk, endRk);\n```\n如上面伪代码所示，如果查询结果轨迹点较少，其实是没问题的。但是当如果在给定查询时间区间内有很多的轨迹点。这种查询就会出现上面描述的问题。\n\n### 存储压缩算法\n思路：我们能不能把一个人的散列轨迹数据拟合成一段轨迹记录。比如，小件员一天的轨迹散列，我们通过离线任务将其拟合成一条完整的轨迹记录。按天轨迹的查询Hbase的压力转移到了单条轨迹记录的查询压力。如果单条轨迹某一列数据较大同样会产生性能问题。那么我们接下来想办法压缩这单条数据就OK了。\n\n#### 10进位转高进位算法压缩\n假如我们用一下方式存储一个用户一段时间的完整轨迹数据\n```java\n #Line(lon1,lat1;lon2,lat2;..........lonN,latN)\n```\n那么，如果我们按照经纬度原始字符串存储，那么当轨迹点较多时会是一个比较大的存储压力。这时，我们可以使用经纬度转高经纬度的方案采取压缩。具体实施如下：\n```java\n    //1. 将经纬度转为整数\n    int lonLatNum = (int) lonLat * 1000000;\n    StringBuilder sb ;\n    Stack s;\n    // 2. 循环编码\n    while(n != 0)\n        int index = n % radix\n        char c = getChar(index);\n        n /= radix;\n        s.push(c);\n    while(!s.empty())\n        sb.append(s.pop());\n    \n```\n这样经过几次转换，10位的经纬度字符串就压缩为3，4位的字符串了。这种压缩方式的压缩比例经测试大概是72%左右\n\n\n#### 差值压缩\n这种压缩思路是，我们只记录轨迹序列第一个轨迹点的精确值，后面的经纬度信息只保留与第一个经纬度之间的差值\n```java\n    StringBuilder.append(Lon[0]).append(',').append(Lat[0]).append(';').append(Lon[1] - Lon[0]).append(',').append(Lat[1]-Lat[0])....append(Lon[n] - Lon[n-1]).append(',').append(Lat[n] - Lat[n-1]));\n```\n这种压缩算法在经纬度精度越大的时候效果越明显。经测试，当经纬度为6位小数位精度时，压缩比可以到达75%。而且在[100 - &)的区间里，压缩比非常稳定。\n"},{"title":"基于Github Pages的React Blog接入Gitalk组件","tag":["blog","gitalk"],"time":"2020-07-08 10:30:02","url":"/post/2020-07-08T10:30:02_gitalk","thumb":"/contents/2020-07-08T10:30:02_gitalk/thumb.jpg","content":"## 什么是gitalk\n随着github pages的推出，人们可以低成本的生成自己的静态博客。但是基于这样的静态博客，我们还可能有更加丰富的需求。比如比较常见的给博客添加评论功能。现在市面上有不少支持静态博客网站的云评论插件，比如搜狐的畅言，之前网易的云评论等。\ngitalk跟其他云评论类似，也是一个支持静态网站评论的工具。不同点是，gitalk不会把评论内容托管到自己的服务后台，而是直接利用了github的issues功能。将评论内容直接托管在了github。几款常见云评论对比：\n\n|  插件   | 是否免费  | 是否有广告  | 是否支持react  |\n|  ----  | ----  | ----  | ----  |\n| 畅言  | 收费/免费功能受限、有广告 | 免费版有 | 不支持，需要自行转换 |\n| 大话云评论 | 免费 | 无广告，但随时可能停运 | 不支持，需要自行转换 |\n| gitalk | 免费开源 | 无广告，github在就不会停运 | 支持react |\n\n通过几款云评插件对比，Gitalk相对来说比较稳定，可靠。而且在开源社区共同维护，又支持react等方式接入。总体上是一个比较不错的选择。\n\n### gitalk效果图\n![Directory tree](/contents/2020-07-08T10:30:02_gitalk/20200708225443.jpg)\n\n## 如何接入gitalk\n\n> 参考官方教程:https://github.com/gitalk/gitalk/blob/master/readme-cn.md\n\n### 注册github application\n\n注册的时候需要注意的点是：\n1. 两个地址，都必须填写，并且有一个地址必须是博客得访问地址。为了保险起见，都填写博客访问地址就OK拉\n2. 注册好app后，会生成clientId等安全信息，这些信息后面会用到\n3. 注册app使用的github不一定要跟博客托管的github是一个账号，或者同一个仓库。这个根据实际需求配置就好了。\n\n### 项目中引入gitalk\n\ngitalk支持两种方式进行引入，根据项目实际情况选择即可\n\n#### 方式1\n\n添加一个容器：\n\n```html\n<div id=\"gitalk-container\"></div>\n```\n\n用下面的 Javascript 代码来生成 gitalk 插件：\n\n```js\nvar gitalk = new Gitalk({\n  clientID: 'GitHub Application Client ID',\n  clientSecret: 'GitHub Application Client Secret',\n  repo: 'GitHub repo',\n  owner: 'GitHub repo owner',\n  admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'],\n  id: location.pathname,      // Ensure uniqueness and length less than 50\n  distractionFreeMode: false  // Facebook-like distraction free mode\n})\n\ngitalk.render('gitalk-container')\n```\n\n#### 方式2：在React使用\n\n使用以下代码引入Gitalk组件\n\n```jsx\nimport GitalkComponent from \"gitalk/dist/gitalk-component\";\n```\n\n按以下方式在React中使用Gitalk组件\n\n```jsx\n<GitalkComponent options={{\n  clientID: \"...\",\n  // ...\n  // 设置项\n}} />\n```  \n上面是官方教程，当我们用方式2进行引入后，**我们会发现引入的插件没有样式**，为了能正常显示插件，我在网上找到的应该引入的样式。\n将上面引入组建的地方添加一行样式引入。\n\n```jsx\nimport 'gitalk/dist/gitalk.css'\nimport GitalkComponent from \"gitalk/dist/gitalk-component\";\n```\n### 设置\n\n- **clientID** `String` \n\n  **必须**. GitHub Application Client ID.\n\n- **clientSecret** `String` \n\n  **必须**. GitHub Application Client Secret.\n\n- **repo** `String` \n\n  **必须**. GitHub repository.\n\n- **owner** `String` \n\n  **必须**. GitHub repository 所有者，可以是个人或者组织。\n\n- **admin** `Array` \n\n  **必须**. GitHub repository 的所有者和合作者 (对这个 repository 有写权限的用户)。\n\n- **id** `String` \n  \n  Default: `location.href`.\n\n  页面的唯一标识。长度必须小于50。\n  \n- **number** `Number` \n  \n  Default: `-1`.\n\n  页面的 issue ID 标识，若未定义`number`属性则会使用`id`进行定位。\n\n- **labels** `Array` \n  \n  Default: `['Gitalk']`.\n\n  GitHub issue 的标签。\n\n- **title** `String` \n  \n  Default: `document.title`.\n\n  GitHub issue 的标题。\n\n- **body** `String` \n  \n  Default: `location.href + header.meta[description]`.\n\n  GitHub issue 的内容。\n\n- **language** `String` \n  \n  Default: `navigator.language || navigator.userLanguage`.\n\n  设置语言，支持 [en, zh-CN, zh-TW]。\n\n- **perPage** `Number` \n  \n  Default: `10`.\n\n  每次加载的数据大小，最多 100。\n\n- **distractionFreeMode** `Boolean` \n  \n  Default: false。\n\n  类似Facebook评论框的全屏遮罩效果.\n\n- **pagerDirection** `String`\n\n  Default: 'last'\n\n  评论排序方式， `last`为按评论创建时间倒叙，`first`为按创建时间正序。\n\n- **createIssueManually** `Boolean` \n  \n  Default: `false`.\n\n  如果当前页面没有相应的 isssue 且登录的用户属于 admin，则会自动创建 issue。如果设置为 `true`，则显示一个初始化页面，创建 issue 需要点击 `init` 按钮。\n\n- **proxy** `String` \n\n  Default: `https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token`.\n\n   GitHub oauth 请求到反向代理，为了支持 CORS。 [为什么要这样?](https://github.com/isaacs/github/issues/330)\n\n- **flipMoveOptions** `Object` \n  \n  Default:\n  ```js\n    {\n      staggerDelayBy: 150,\n      appearAnimation: 'accordionVertical',\n      enterAnimation: 'accordionVertical',\n      leaveAnimation: 'accordionVertical',\n    }\n  ```\n\n  评论列表的动画。 [参考](https://github.com/joshwcomeau/react-flip-move/blob/master/documentation/enter_leave_animations.md)\n\n- **enableHotKey** `Boolean` \n  \n  Default: `true`.\n\n  启用快捷键(cmd|ctrl + enter) 提交评论.\n\n\n### 实例方法\n\n- **render(String/HTMLElement)**\n\n  初始化渲染并挂载插件。\n\n### TypeScript\n\n已经包括了配置项和Gitalk类的类型定义，不包括React组件的类型定义。\n\n### 开启评论\n组件添加好后，我们会看到如下显示：\n![没有评论图示](/contents/2020-07-08T10:30:02_gitalk/20200708231613.jpg) \n这是本篇文章还没有在github上创建第一个issues，需要我们手动创建一个issue。创建Issue时需要注意的点事\n1. 这个issue必须有两个标签 \n   1. Gtalk标签\n   2. 文章唯一ID对应的标签\n2. 创建ID标签时，长度不容许超过50个字符，并且标签对字符有限制(尽量不要写奇形怪状的字符就行)，创建好标签后的样子如下：\n![给文章创建的ISSUE图示](/contents/2020-07-08T10:30:02_gitalk/20200708232207.jpg) \n\n### 踩过的坑\n1. 插件没有样式的问题，上面已经提到，方式2需要在官方教程引入Gitalk插件组件时，还得引入相应的样式文件。\n2. Gitalk配置中的ID，这个有50字符长度的限制。而gitalk本身有个默认限制，那就是获取文章对于的完整url。这种情况下大概率会出现ID超过50长度的限制。所以这个ID尽量要自己设置，我们可以给每个文章生成一个唯一字符串，这个字符串用来做gitalk的文章ID\n3. \n\n"},{"title":"LINUX各种IO模型","tag":["java","linux","io"],"time":"2020-07-15 06:54:34","url":"/post/2020-07-15T06:54:34_linux-io","thumb":"/contents/2020-07-15T06:54:34_linux-io/thumb.jpg","content":"# IO种类\nlinux下有五种IO模型，阻塞IO，非阻塞IO，多路复用IO，信号驱动IO，异步IO。\n\n为了区分清楚这几种IO的区别，我们首先要弄明白什么是阻塞，什么是异步。\n\n## 什么是阻塞，非阻塞\n> 首先阻塞，非阻塞是对IO操作发起者的一种状态描述\n> 阻塞：线程A执行某个IO操作，从A发起IO之后，他就一直等着响应，这种场景下，A就是被阻塞的。这种IO操作就是阻塞IO。\n> 非阻塞：线程A发起某个IO操作，之后线程A不会死等着IO完成，而是在等待的过程间隙去干其他的事情，在干别的事情的过程中会时不时的看一下IO是不是OK了。\n\n## 什么是同步，异步\n> 同步异步，是IO操作本身处理方式的一种描述\n> 同步：线程A发起IO操作时，系统执行IO，知道IO执行完成，同步返回响应给线程A。\n> 异步：线程A发起IO操作时，系统收到请求后直接返回接收响应，线程A就不用继续等待，做自己想做的事情就好了。系统IO完毕，会通过某种方式通知线程A执行完成。\n\n举个例子总结一下：假如你去饭店吃饭，点好了菜，如果你在柜台等菜好了自己端到餐桌，并且等菜期间啥也不做，那么就是阻塞IO；如果你在柜台等菜期间刷会儿抖音，那就是非阻塞IO；如果店员跟你说，我们店不支持送餐到桌，客人必须自己在柜台那号等餐，那就是同步IO；如果店员说，客人可以先去餐桌，等菜好了叫客人去拿，这就是信号驱动IO；如果这家店服务特别周到，客人直接扫码点餐，点好之后客人啥也不用做，菜好了店员会自动送过来，这就是异步IO了。\n\n# 阻塞IO\n![图片来源：google 搜索](/contents/2020-07-15T06:54:34_linux-io/640.jpg)\n我们钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。\n\n映射到Linux操作系统中，这就是一种最简单的IO模型，即阻塞IO。 阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。\n\n应用进程通过系统调用 recvfrom 接收数据，但由于内核还未准备好数据报，应用进程就会阻塞住，直到内核准备好数据报，recvfrom 完成数据报复制工作，应用进程才能结束阻塞状态。\n\n这种钓鱼方式相对来说比较简单，对于钓鱼的人来说，不需要什么特制的鱼竿，拿一根够长的木棍就可以悠闲的开始钓鱼了（实现简单）。缺点就是比较耗费时间，比较适合那种对鱼的需求量小的情况（并发低，时效性要求低）。\n\n# 非阻塞IO\n![图片来源：google 搜索](/contents/2020-07-15T06:54:34_linux-io/651.jpg)\n我们钓鱼的时候，在等待鱼儿咬钩的过程中，我们可以做点别的事情，比如玩一把王者荣耀、看一集《延禧攻略》等等。但是，我们要时不时的去看一下鱼竿，一旦发现有鱼儿上钩了，就把鱼钓上来。\n\n映射到Linux操作系统中，这就是非阻塞的IO模型。应用进程与内核交互，目的未达到之前，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据准备有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中。\n\n应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回error，应用进程在得到error后，过一段时间再发送recvfrom请求。在两次发送请求的时间段，进程可以先做别的事情。\n\n这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。\n\n# 信号驱动IO\n![图片来源：google 搜索](/contents/2020-07-15T06:54:34_linux-io/652.jpg)\n我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。\n\n映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。\n\n应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。\n这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。\n\n# IO复用\n![图片来源：google 搜索](/contents/2020-07-15T06:54:34_linux-io/653.jpg)\n我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。\n\n映射到Linux操作系统中，这就是IO复用模型。多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。\nIO多路转接是多了一个select函数，多个进程的IO可以注册到同一个select上，当用户进程调用该select，select会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，select调用进程会阻塞。当任意一个IO所需的数据准备好之后，select调用就会返回，然后进程在通过recvfrom来进行数据拷贝。\n\n这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的。进程在发出select后，要等到select监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。\n\n> 为什么以上四种都是同步的\n> 我们说阻塞IO模型、非阻塞IO模型、IO复用模型和信号驱动IO模型都是同步的IO模型。原因是因为，无论以上那种模型，真正的数据拷贝过程，都是同步进行的。\n> 信号驱动难道不是异步的么？ 信号驱动，内核是在数据准备好之后通知进程，然后进程再通过recvfrom操作进行数据拷贝。我们可以认为数据准备阶段是异步的，但是，数据拷贝> 操作是同步的。所以，整个IO过程也不能认为是异步的。\n\n# 异步IO模型\n![图片来源：google 搜索](/contents/2020-07-15T06:54:34_linux-io/655.jpg)\n我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。\n\n映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。\n\n用户进程发起aio_read操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到aio_read后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户控件，然后再通知进程本次IO已经完成。\n\n这种方式的钓鱼，无疑是最省事儿的。啥都不需要管，只需要交给鱼竿就可以了。\n\n# 五种模型对比\n![图片来源：google 搜索](/contents/2020-07-15T06:54:34_linux-io/656.jpg)\n\n**异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O**"},{"title":"深入理解JVM ClassLoader","tag":["JVM","ClassLoader"],"time":"2020-07-16 10:46:08","url":"/post/2020-07-16T10:46:08_jvm-classloader","thumb":"/contents/2020-07-16T10:46:08_jvm-classloader/thumb.jpg","content":"# 引子\n作为JAVA开发人员，我们经常会遇到这个异常 java.lang.ClassNotFoundExcetpion。现在我们知道，报了这个异常是因为我们的运行时空间里找不到需要被加载的类。那么JVM到底是如何查找要加载的类，找到类又是如何加载到内存的呢。\n\n# 类加载器\njava世界中的类都是被所谓的ClassLoader加载到内存的。目前JVM提供了三种预定义类加载器。\n\n启动（Bootstrap）类加载器：启动类加载器是用本地代码实现的类加载器，它负责将JAVA_HOME/lib下面的核心类库或-Xbootclasspath选项指定的jar包等虚拟机识别的类库加载到内存中。由于启动类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用。具体可由启动类加载器加载到的路径可通过System.getProperty(“sun.boot.class.path”)查看。\n\n扩展（Extension）类加载器：扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的，它负责将JAVA_HOME /lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器，具体可由扩展类加载器加载到的路径可通过System.getProperty(\"java.ext.dirs\")查看。\n\n系统（System）类加载器：系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的，它负责将用户类路径(java -classpath或-Djava.class.path变量所指的目录，即当前类所在路径及其引用的第三方类库的路径，如第四节中的问题6所述)下的类库加载到内存中。开发者可以直接使用系统类加载器，具体可由系统类加载器加载到的路径可通过System.getProperty(\"java.class.path\")查看。\n\n# 类如何被加载到内存？\n\n刚学JAVA的同学也许会有这样的疑问，既然JDK内部有定义了java.lang.String类。我们自己能不能定义一个类，也叫java.lang.String呢？实验结果表明，即使我们定义了自己的String,JVM还是加载的JDK内部的String类。那么JVM到底是怎么加载类的呢？JVM是如何识别哪个是JDK的String还是我们自己定义的伪String.这是因为JVM使用了传说中的双亲委派类加载策略了。\n\n\n# 啥是双亲委派机制？\n\nJVM在加载类时默认采用的是双亲委派机制。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归 (本质上就是loadClass函数的递归调用)，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。如果父类加载器可以完成这个类加载请求，就成功返回；只有当父类加载器无法完成此加载请求时，子加载器才会尝试自己去加载。事实上，大多数情况下，越基础的类由越上层的加载器进行加载，因为这些基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API（当然，也存在基础类回调用户用户代码的情形，即破坏双亲委派模型的情形）。 关于虚拟机默认的双亲委派机制，我们可以从系统类加载器和扩展类加载器为例作简单分析。\n\n![类加载](/contents/2020-07-16T10:46:08_jvm-classloader/aaa.jpg)\n\n![类加载](/contents/2020-07-16T10:46:08_jvm-classloader/Xnip2020-07-16_23-26-39.jpg)\n\n上面两张图分别是扩展类加载器继承层次图和系统类加载器继承层次图。通过这两张图我们可以看出，扩展类加载器和系统类加载器均是继承自 java.lang.ClassLoader抽象类。我们下面我们就看简要介绍一下抽象类 java.lang.ClassLoader 中几个最重要的方法：\n\n```java\n//加载指定名称（包括包名）的二进制类型，供用户调用的接口  \npublic Class<?> loadClass(String name) throws ClassNotFoundException{ … }  \n  \n//加载指定名称（包括包名）的二进制类型，同时指定是否解析（但是这里的resolve参数不一定真正能达到解析的效果），供继承用  \nprotected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException{ … }  \n  \n//findClass方法一般被loadClass方法调用去加载指定名称类，供继承用  \nprotected Class<?> findClass(String name) throws ClassNotFoundException { … }  \n  \n//定义类型，一般在findClass方法中读取到对应字节码后调用，final的，不能被继承  \n//这也从侧面说明：JVM已经实现了对应的具体功能，解析对应的字节码，产生对应的内部数据结构放置到方法区，所以无需覆写，直接调用就可以了）  \nprotected final Class<?> defineClass(String name, byte[] b, int off, int len) throws ClassFormatError{ … } \n```\n\n通过进一步分析标准扩展类加载器和系统类加载器的代码以及其公共父类（java.net.URLClassLoader和java.security.SecureClassLoader）的代码可以看出，都没有覆写java.lang.ClassLoader中默认的加载委派规则 — loadClass（…）方法。既然这样，我们就可以从java.lang.ClassLoader中的loadClass（String name）方法的代码中分析出虚拟机默认采用的双亲委派机制到底是什么模样：\n\n```java\n protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // 1. 校验类是否之前已经被加载过这个类\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n                        // 2. 如果本加载器有父类加载器，那么优先使用父加载器进行加载\n                        c = parent.loadClass(name, false);\n                    } else {\n                        // 3. 如果父加载器为空，就使用BootstrapClassLoader加载\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    // 4. 如果父加载器没有加载到类，就调用本加载器的findClass\n                    long t1 = System.nanoTime();\n                    c = findClass(name);\n\n                   ...\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n从上面类加载的代码可知，类被当前的加载器加载时，先会被判断是否之前已经被加载过，如果父加载器可以被加载到就会优先使用类加载器已经加载过的类。这样就能解释，为什么当我们自己也定义了java.lang.String不会被JVM加载了。\n\n# 三个预置加载器的关系\nsun.misc.Launcher类是java的入口，在启动java应用的时候会首先创建Launcher类，创建Launcher类的时候回准备应用程序运行中需要的类加载器。\n我们简单读一下这个类的代码\n```java\n\n// java 启动器\npublic Launcher() {\n\n        Launcher.ExtClassLoader var1;\n        try {\n            // 1. 构造拓展类加载器\n            var1 = Launcher.ExtClassLoader.getExtClassLoader();\n        } catch (IOException var10) {\n            throw new InternalError(\"Could not create extension class loader\", var10);\n        }\n\n        try {\n            // 2. 获取App类加载器，并将拓展加载器作为App加载器的父加载器\n            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);\n        } catch (IOException var9) {\n            throw new InternalError(\"Could not create application class loader\", var9);\n        }\n\n        Thread.currentThread().setContextClassLoader(this.loader);\n        String var2 = System.getProperty(\"java.security.manager\");\n\n        if (var2 != null) {\n            ...\n        }\n\n    }\n\n// 获取拓展类加载器\nstatic class ExtClassLoader extends URLClassLoader {\n\n        // 加载器实例对象\n        private static volatile Launcher.ExtClassLoader instance;\n\n        // 通过单例模式创建加载器\n        public static Launcher.ExtClassLoader getExtClassLoader() throws IOException {\n            \n            if (instance == null) {\n                Class var0 = Launcher.ExtClassLoader.class;\n                synchronized(Launcher.ExtClassLoader.class) {\n                    if (instance == null) {\n                        instance = createExtClassLoader();\n                    }\n                }\n            }\n\n            return instance;\n        }\n    \n\n```\n其中拓展类加载器没有被指定父加载器，是因为拓展加载器上层就是Bootstrap加载器了。这个加载器是C语言编写的，无法直接获取这个加载器的实例。而AppClassLoader的父加载器是ExtClassLoader。所以这三个加载器的大致关系如下：\n\n![类加载](/contents/2020-07-16T10:46:08_jvm-classloader/Xnip2020-07-18_17-04-56.jpg)\n\n对于双亲委派，我们做下面实验\n\n1. 定义测试类，并输出类加载器和父类加载器\n```java\npackage com.melon.classload;\npublic class ParentDelegate {  \n    public ParentDelegate() { }  \n}  \n\n@Test\npublic void classLoaderInfo() {\n    try {\n        //调用加载当前类的类加载器（这里即为系统类加载器）加载TestBean\n        Class typeLoaded = Class.forName(\"com.melon.classload.ParentDelegate\");\n        //查看被加载的TestBean类型是被那个类加载器加载的\n        System.out.println(typeLoaded.getClassLoader());\n        System.out.println(typeLoaded.getClassLoader().getParent());\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n输出结果：\nsun.misc.Launcher$AppClassLoader@18b4aac2\nsun.misc.Launcher$ExtClassLoader@45fe3ee3\n\n2. 将代码打包复制到<jre>/lib/ext下，再次运行\nsun.misc.Launcher$ExtClassLoader@78b4aac2\nnull \n\n可以看出，将jar在不同的目录下，class会被不同的类加载器加载进来。\n\n# 延伸\n1. 由不同的类加载器加载的指定类还是相同的类型吗？\n在同一加载器下，不同的类通过类完全匹配名称来区分，但是类在不同的类加载器中，会根据加载器实例+类的全名进行区分的。也就是说，类在不同的加载器中会有不同的命名空间。这样当一个相同的自定义类被不同的类加载器加载时，两个类在JVM的角度上并不是一个类型。\n\n2. 自定义一个java.lang.String放到<JRE>/lib下可以覆盖系统的String类型么\n答案是不能，JVM在Bootstrap加载器中对java做了保护，启动加载器只会加载认可的合法类，我们自定义的String类不是系统认可的类，所以不会被加载。\n\n3. 使用反射进行类加载时，使用的是哪个类加载器\n直接上源码\n\n```java\n//java.lang.Class.java  \npublicstatic Class<?> forName(String className) throws ClassNotFoundException {  \n    return forName0(className, true, ClassLoader.getCallerClassLoader());  \n}  \n  \n//java.lang.ClassLoader.java  \n// Returns the invoker's class loader, or null if none.  \nstatic ClassLoader getCallerClassLoader() {  \n    // 获取调用类（caller）的类型  \n    Class caller = Reflection.getCallerClass(3);  \n    // This can be null if the VM is requesting it  \n    if (caller == null) {  \n        return null;  \n    }  \n    // 调用java.lang.Class中本地方法获取加载该调用类（caller）的ClassLoader  \n    return caller.getClassLoader0();  \n}  \n  \n//java.lang.Class.java  \n//虚拟机本地实现，获取当前类的类加载器，前面介绍的Class的getClassLoader()也使用此方法  \nnative ClassLoader getClassLoader0(); \n```\n可以看到，forName使用的是caller的类加载器\n\n"}]